<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>360T7升级openwert</title>
      <link href="/2023/10/27/360T7%E5%8D%87%E7%BA%A7openwert/"/>
      <url>/2023/10/27/360T7%E5%8D%87%E7%BA%A7openwert/</url>
      
        <content type="html"><![CDATA[<h1 id="360T7-升级-openwrt"><a href="#360T7-升级-openwrt" class="headerlink" title="360T7 升级 openwrt"></a>360T7 升级 openwrt</h1><h2 id="360T7-配置"><a href="#360T7-配置" class="headerlink" title="360T7 配置"></a>360T7 配置</h2><p>MT7981(filogic 820)</p><ul><li>CPU：MT7981B 双核 A53 1.3GHz ，架构 aarch64_cortex-a53</li><li>RAM：256M DDR3</li><li>FLASH：128M SPI NAND</li><li>无线 phy：MT7976CN AX3000</li><li>交换机：MT7531A 2xHSGMII</li></ul><p>原厂 UBoot 启动时，只能使用一个 ubi 分区存放固件，固件总体积（含 kernel+rootfs+rootfs_data）将限制在 36M 内，但仍然可以使用 plugin 分区（36M）存放其它数据。因此，原厂的 UBoot 只能使用小于 36M 的固件，较大的固件超过了存放 ubi 的分区就不能使用。</p><h2 id="分区信息"><a href="#分区信息" class="headerlink" title="分区信息"></a>分区信息</h2><ul><li>Factory 为无线 EEPROM 分区</li><li>fip 为 uboot 分区</li><li>ubi 为固件分区，36M，ubi 格式</li><li>firmware-1 为固件分区，36M，ubi 格式</li><li>plugin 为原厂插件分区，36M，ubi 格式</li><li>factory 为原厂固件信息分区，保存有机器编号，MAC 地址等信息</li></ul><h2 id="开启-telnet"><a href="#开启-telnet" class="headerlink" title="开启 telnet"></a>开启 telnet</h2><ol><li>拆机。<br>用卡片撬动，可以无损开机，需要注意卡扣方向。</li><li>找到 UART 串口。<br>拆机后找到，主板正面（贴芯片的一面），左上方侧边三个圆孔，线序从上到下一次为 RXD,TXD,GND，分别对应读、写、地。波特率为&#96;115200</li><li>使用串口工具，连接路由器，串口工具的读对应路由器 UART 的写，地对地。不要接错！</li><li>使用串口助手，路由器通电，等待启动，不断按 <code>F</code>和回车键，直到出现以下提示进入 failsafe 模式。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Press the <span class="selector-attr">[f]</span> key and hit <span class="selector-attr">[enter]</span> <span class="selector-tag">to</span> enter failsafe mode</span><br><span class="line">Press the <span class="selector-attr">[1]</span>, <span class="selector-attr">[2]</span>, <span class="selector-attr">[3]</span> or <span class="selector-attr">[4]</span> key and hit <span class="selector-attr">[enter]</span> <span class="selector-tag">to</span> select the debug level</span><br></pre></td></tr></table></figure><ol start="4"><li>failsafe 下执行以下操作</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启uboot控制台菜单</span></span><br><span class="line">fw_setenv bootmenu_delay <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载rootfs并开启telnet</span></span><br><span class="line">mount_root</span><br><span class="line">sed -i <span class="string">&#x27;s/.*local debug=.*/\tlocal debug=1/&#x27;</span> <span class="regexp">/etc/i</span>nit.d/telnet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改root密码</span></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><ol start="5"><li>重启。 <code>reboot</code></li></ol><h2 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h2><p>基于 bl-mt798x 项目<br><a href="https://github.com/hanwckf/bl-mt798x/tree/20230902">mt798x uboot</a></p><ul><li>CPU : mt798</li><li>BOARD : 360t7</li><li>默认地址 ：192.168.1.1</li><li>固件分区 108M，原厂固件分区 36M</li><li>带有 webui 恢复页面</li><li>支持多种 Flash 分区布局切换</li></ul><h3 id="刷入-UBoot"><a href="#刷入-UBoot" class="headerlink" title="刷入 UBoot"></a>刷入 UBoot</h3><ol><li>下载该修改版 UBoot:mt798x-uboot-202206-fip.tar.xz,解压缩出 bin 文件。</li><li>将 Uboot bin 文件上传到路由器,并写进 fip。<br>使用 ssh 将文件上传到&#x2F;tmp,直接使用 wegt 下载到&#x2F;tmp 也可以。上传文件以后，执行 <code>mtd write mt7981_360t7-fip-fixed-parts.bin fip</code>写入 UBoot 文件，刷 UBoot 完成。</li></ol><h2 id="刷入固件"><a href="#刷入固件" class="headerlink" title="刷入固件"></a>刷入固件</h2><ol><li>完成 UBoot 写入以后，断电，修改电脑 IP 为 192.168.1.2，子网掩码 255.255.255.0，网关 192.168.1.1，dns 192.168.1.1.按住路由器 RESET 按键，通电，等待 8s 后使用访问 192.168.1.1 进入 uboot 恢复页面。 2.选择固件，写入。 3.重启完成。</li></ol><h2 id="failsafe-webui-使用方法"><a href="#failsafe-webui-使用方法" class="headerlink" title="failsafe webui 使用方法"></a>failsafe webui 使用方法</h2><ol><li>按住路由器 RESET 键孔后通电，保持 10-15 秒后松开按键，路由器自动进入 failsafe 模式。</li><li>uboot 不支持 DHCP,需要电脑网线接路由期 lan 口，配置电脑 ip 为固定 IP 设置 <code>192.168.1.100</code>。</li><li>使用浏览器的 隐身模式 访问路由器 ip <code>192.168.1.1</code></li><li>选择固件上传，支持 sysupgrade 和 factory 格式的固件，上传完毕后点击开始刷机。</li><li>固件写入后，路由器会自动撑起，请将电脑 ip 地址重新设置成 DHCP 自动获取。</li><li>要使用 webui 更新 uboot,可以访问 <code>http：//&lt;路由ip&gt;/uboot.html</code> ,选择 FIP 格式的 uboot 二进制文件并上传刷如即可。</li></ol><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>mt798x-uboot-202206-fip.tar.xz</p><h2 id="官方-openwrt"><a href="#官方-openwrt" class="headerlink" title="官方 openwrt"></a>官方 openwrt</h2><blockquote><p>⚠️ 注意： 这里仅限原厂分区即 36M UBoot 使用的，修改版的 Uboot 运行情况没测试。<br>因为没有 NMBM,所以需要刷机前在 failsafe mode 备份所有 mtd 分区。</p></blockquote><h3 id="需要文件"><a href="#需要文件" class="headerlink" title="需要文件"></a><a href="https://downloads.openwrt.org/snapshots/targets/mediatek/filogic/">需要文件</a></h3><ul><li><p>openwrt-23.05.0-mediatek-filogic-qihoo_360t7-bl31-uboot.fip<br>ATF uboot 文件，似乎不支持 108M Uboot。</p></li><li><p>openwrt-23.05.0-mediatek-filogic-qihoo_360t7-initramfs-recovery.itb</p></li><li><p>openwrt-23.05.0-mediatek-filogic-qihoo_360t7-preloader.bin<br>ATF BL2 文件</p></li><li><p>openwrt-23.05.0-mediatek-filogic-qihoo_360t7-squashfs-sysupgrade.itb</p></li></ul><h2 id="hanwckf-版"><a href="#hanwckf-版" class="headerlink" title="hanwckf 版"></a>hanwckf 版</h2><h3 id="hanwckf-编译版"><a href="#hanwckf-编译版" class="headerlink" title="hanwckf 编译版"></a>hanwckf 编译版</h3><p><a href="https://www.right.com.cn/forum/thread-8290125-1-1.html">恩山论坛</a></p><p>在 github 上有个一个基于 hanwckf 的编译版，<a href="https://github.com/weigefenxiang/360T7/releases/tag/latest">在这里可以找到</a>。<br>基于修改的 108M 的 Uboot,比较纯净。</p><h2 id="openwrt-的文件结构参考"><a href="#openwrt-的文件结构参考" class="headerlink" title="openwrt 的文件结构参考"></a>openwrt 的文件结构参考</h2><p>分区结构 <code>df -h</code></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- /</span><br><span class="line">  |- dev</span><br><span class="line">  |  |- root              # 根文件系统</span><br><span class="line">  |  |- ubi0_2            # UBI 设备的第二个分区</span><br><span class="line">  |</span><br><span class="line">  |- tmpfs                # 基于内存的临时文件系统</span><br><span class="line">  |</span><br><span class="line"><span class="title">  |- overlayfs:</span>/overlay   # Overlay 文件系统的挂载点，用于系统修改和用户自定义</span><br><span class="line">  |</span><br><span class="line">  |- ...</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">  <span class="number">1</span>. `/dev/root`：这是根文件系统（root filesystem），它通常是只读的。它包含了操作系统的核心组件和基本文件。在启动过程中，它通常被挂载为只读文件系统。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. `tmpfs`：`tmpfs` 是一种基于内存的临时文件系统。它在内存中创建一个文件系统，用于存储临时数据，例如临时文件、日志文件等。`tmpfs` 是易失性的，意味着在系统重启后，其中存储的数据将丢失。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. `/dev/ubi0_2`：这表示 UBI（Unsorted Block Images）设备的第二个分区。UBI 是用于处理闪存设备的抽象层，它允许将闪存分区虚拟化为逻辑块设备。`/dev/ubi0_2` 可能是一个可读写的分区，用于存储用户数据或配置。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. `overlayfs:/overlay`：`overlayfs` 是一种联合文件系统，允许将多个文件系统层叠在一起。`/overlay` 表示一个 overlayfs 文件系统的挂载点，它是用于存储系统修改和用户自定义的文件系统。通常，`/overlay` 是可读写的，并且用于存储用户安装的软件包、配置更改和其他系统修改。</span><br><span class="line"></span><br><span class="line"><span class="title">这些文件系统在 OpenWrt 中扮演着不同的角色。其中，根文件系统包含了操作系统的核心组件和基本文件，`tmpfs` 用于临时存储，`/dev/ubi0_2` 可能是存储用户数据的分区，而 `overlayfs:</span>/overlay` 则用于存储系统修改和用户自定义的文件系统。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">├── dev</span><br><span class="line">│   ├── mtdblockX       # 存储闪存芯片上的分区</span><br><span class="line">│   ├── mmcblk0pX       # SD卡或eMMC存储器的分区</span><br><span class="line">│   └── sdXN            # 外部USB存储设备的分区</span><br><span class="line">├── etc                 # 系统配置文件</span><br><span class="line">├── bin                 # 可执行文件</span><br><span class="line">├── sbin                # 系统可执行文件</span><br><span class="line">├── usr                 # 用户程序和数据</span><br><span class="line">│   ├── bin             # 用户可执行文件</span><br><span class="line">│   ├── sbin            # 用户系统可执行文件</span><br><span class="line">│   ├── lib             # 库文件</span><br><span class="line">│   ├── lib64           # 64位库文件</span><br><span class="line">│   ├── include         # 头文件</span><br><span class="line">│   ├── share           # 共享数据</span><br><span class="line">│   └── ...</span><br><span class="line">├── tmp                 # 临时文件</span><br><span class="line">├── proc                # 内核和进程信息</span><br><span class="line">├── sys                 # 系统相关信息</span><br><span class="line">├── mnt                 # 挂载点</span><br><span class="line">├── var                 # 可变数据</span><br><span class="line">├── www                 # Web服务器根目录</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ul><li></li><li>cat &#x2F;proc&#x2F;mtd<br>查找分区的名称。在列出的输出中，可以看到每个分区的名称、起始地址和大小。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ios 捷径 (ShortCuts)笔记</title>
      <link href="/2023/10/24/Ios-%E6%8D%B7%E5%BE%84-ShortCuts-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/24/Ios-%E6%8D%B7%E5%BE%84-ShortCuts-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Ios-捷径-ShortCuts"><a href="#Ios-捷径-ShortCuts" class="headerlink" title="Ios 捷径 (ShortCuts)"></a>Ios 捷径 (ShortCuts)</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>用途<br>标记 和 存储 内容（如文本、图像、网页、数据词典等）</li><li>类型<ul><li>魔法变量<br>捷径中任一操作的 结果输出 都可以当作用于后续操作的变量，这个变量就是魔法变量。<br>魔法变量可以改变数据类型。点击变量名称即可进入修改变量的详细信息，</li><li>特殊变量<br>在设定变量的过程中或添加到参数的过程，点击 输入 ，可显示： 每次询问 、 剪贴板 、 当前日期 、 设备详细信息 、 输入快捷指令的信息 这些特殊变量。<br>特殊变量也可通过点击 名称 或 文本栏 修改该变量的详细信息。</li><li>手动变量<br>自行设定的变量。可以保留稍后需要修改的值，也可以给现有的变量添加信息。<br>操作方式：设定变量 或 添加到变量。<br>设定变量：首次设定一个新变量，或者 覆盖 之前存储过的变量。<br>添加到变量：可以将多个内容添加到同意个变量，每次运行语句都将内容追加到变量中，从而将数据存储为一个有序列表。[ 这时的变量是一个数组 ]<br>手动变量会降低代码的可读性。通过将 变量 存储到 列表 中可以实现 添加到变量 的大多数功能。</li></ul></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>用途<br>创建有序的数据列表，然后传递到后续操作，也可以使用列表缩小列表范围限制传递的内容。</li><li>操作<ul><li>列表<br>通过输入文本或者插入变量来创建有序列表。<br>将变量添加到列表的文本串中，会将变量强制转换为文本并插入列表项目中<br>列表可实现 手动添加变量 类似的效果。</li><li>从列表中选取<br>运行时显示选项菜单。<br>一般与 词典 搭配使用，使用 词典 来传递列表内容<br>选择列表内容预览时是富文本预览，可预览图片等信息</li><li>从列表中获取项目<br>列表中存储的每一个数据都成为是一个项目<br>一般设置在 列表 之后，对列表的内容进行缩减，从列表中取回单个项目。<br>可选：第一项、最后一项、随机项等<br>列表的内容中第一项的索引为 1 。可通过设定索引范围实现返回列表中的多个项目</li></ul></li></ul><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><ul><li>用途<br> 可通过菜单选择决定后续的操作，可以通过菜单预定义选项类别，不同的选项对应不同的操作。</li></ul><h3 id="菜单-和-列表-的区别"><a href="#菜单-和-列表-的区别" class="headerlink" title="菜单 和 列表 的区别"></a>菜单 和 列表 的区别</h3><blockquote><p>菜单是显示选项列表选择后续的执行操作，列表是将内容存储在列表里供后续选择</p></blockquote><h3 id="如果"><a href="#如果" class="headerlink" title="如果"></a>如果</h3><ul><li>用途<br>用条件判断来决定后续的执行操作。就是编程重点 if 语句</li><li>可以嵌套</li></ul><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><ul><li>用途<br>连续多次运行一组操作，和 为每个项目重复 用途类似。</li><li>操作<br>重复-结束重复 是一个配对标记，会重复运行两个标记之间的操作，可以指定重复次数。<br>重复运行完成以后，重复过程中的每一次迭代的最终结果输出都会集中在一个列表里作为 重复 的结果输出。<br>设置重复的次数时，可配置一个次数变量，实现 每次询问 等操作</li><li>为每个项目重复<br>用于接收列表的项目作为输入，然后针对列表重点每一项运行一次操作。</li><li>重复项目<br>为每个项目重复 中用于跟踪当前项目的特殊变量。</li><li>重复索引<br>用于跟踪当前循环迭代的特殊变量。<br>重复索引变量包含当前循环已经重复的次数。</li></ul><h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><pre><code>&gt; 列表可是看作是一个表格，每个行就可以看作是一个词典，每一行中的各个值就是词典的 value</code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><p>用途<br>主要用于使用 Js 实现对 DOM 的操作。</p></li><li><p>基本格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 Completion 以完成</span></span><br><span class="line"><span class="title function_">completion</span>(result);</span><br></pre></td></tr></table></figure></li></ul><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><ul><li>用途<br>可以通过 ssh 运行脚本，将脚本的结果输出</li></ul><h3 id="查找-过滤"><a href="#查找-过滤" class="headerlink" title="查找 过滤"></a>查找 过滤</h3><h3 id="正则表达式-的使用"><a href="#正则表达式-的使用" class="headerlink" title="正则表达式 的使用"></a>正则表达式 的使用</h3><ul><li>用途<br>用于匹配指定条件的值。<br>常搭配 匹配 查找 等使用</li></ul><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><ul><li>拆分文本<br>使用指定的分隔符，对文本进行分割，分割结果保存进列表。</li><li>更改大小写</li><li>合并文本<br>使用指定的连接符，将文本进行连接起来，实现追加的功能。</li><li>获取匹配文本的组<br>获取符合特定捕获组的文本，或来自“匹配文本”操作输出的所有捕获组。</li><li>获纠正拼写</li><li>匹配文本<br>在传入操作的文本中搜索正则表达式的匹配项。</li><li>替换文本<br>将传入操作的部分文本替换为其他文本。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 捷径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SporifyForMac 破解</title>
      <link href="/2023/10/21/SporifyForMac-%E7%A0%B4%E8%A7%A3/"/>
      <url>/2023/10/21/SporifyForMac-%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Spotify-在-Mac-端和-Linux-端的破解"><a href="#Spotify-在-Mac-端和-Linux-端的破解" class="headerlink" title="Spotify 在 Mac 端和 Linux 端的破解"></a>Spotify 在 Mac 端和 Linux 端的破解</h3><p>来源 - - 「<a href="https://github.com/SpotX-Official/SpotX-Bash">SpotX-Official</a>」</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -sSL https:<span class="regexp">//</span>spotx-official.github.io/run.sh)</span><br></pre></td></tr></table></figure><p>主要是脚本里的 url 404 了，于是修改为了本地版本的</p><p>「<a href="https://github.com/fqw000/SpotifyForMAC/archive/refs/heads/main.zip">下 载 脚 本</a>」将两个 sh 文件下载后放在同一目录下，运行 run.sh 即可。</p><p>run.sh 是用来传递安装参数的<br>默认功能全开启，直接运行「<a href="">spotx.sh</a>」即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spotify </tag>
            
            <tag> 破解 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Surge For Mac 破解</title>
      <link href="/2023/10/21/Surge-For-Mac-%E7%A0%B4%E8%A7%A3/"/>
      <url>/2023/10/21/Surge-For-Mac-%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="SurgeForMac-脚本注入"><a href="#SurgeForMac-脚本注入" class="headerlink" title="SurgeForMac 脚本注入"></a>SurgeForMac 脚本注入</h2><p>来源 - -「 <a href="https://github.com/QiuChenlyOpenSource/InjectLib">InjectLib-QiuChen</a> 」</p><h4 id="以下软件通杀，且不需要关闭-SIP-使用。"><a href="#以下软件通杀，且不需要关闭-SIP-使用。" class="headerlink" title="以下软件通杀，且不需要关闭 SIP 使用。"></a>以下软件通杀，且不需要关闭 SIP 使用。</h4><ul><li>iShot</li><li>InfusePro</li><li>Surge5</li><li>Paste</li><li>ProxyMan</li><li>Parallels Desktop</li><li>Adobe</li></ul><p>「 <a href="https://github.com/QiuChenlyOpenSource/InjectLib/archive/refs/heads/main.zip">下 载 聚 合 脚 本</a> 」</p><ul><li>点击 原神_启动.command 启动脚本，自动检测已安装的应用，在支持的软件提示是否注入，注入即可实现破解。</li><li>运行前 终端 要有足够的权限<ul><li>设置 - 隐私与安全 - 开发者工具 &#x2F; app 管理 - 打开终端-重启终端</li></ul></li><li>注意卸载 surge5 重新安装的步骤<ul><li>先在 surge 里卸载 Helper 帮助程序</li><li>再使用卸载工具完整卸载 surge5</li></ul></li><li>破解之后 Surge5 的模块功能不不能正常 url 添加新模块，需要手动添加。<ul><li>在配置目录下保存模块文件即可</li></ul></li><li>建议将 Surge5 的配置文件路径进行修改。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SurgeForMac </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript笔记</title>
      <link href="/2023/10/17/Javascript%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/17/Javascript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>##JavaScript</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong><em>javascript 的组成</em></strong></p><ul><li>ECMAscript(核心)</li><li>DOM(documents object model 文档对象模型)</li><li>BOM(brower boject model 浏览器对象模型)</li></ul><hr><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><strong><em>datatype (数据类型)</em></strong></p><ul><li><p>原始数据类型</p><ul><li>String</li><li>number</li><li>boolen</li><li>null</li><li>undefined</li><li>Symbol</li><li>BigInt</li></ul></li><li><p>复合数据类型</p><ul><li>object （其中包含 function）<br><code>函数也是对象，对象是包含多个值的变量</code></li></ul></li></ul><blockquote><p>一切皆是对象</p></blockquote><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><ul><li>&#96; typeof 是操作符不是方法，所以后可以及加()也可以不加 &#x2F;&#x2F; 用于检测数据类型</li><li>类型转换：Number() parseIne() parseFloat() （要注意大小写规范）</li><li>NaN isNaN<br>NaN 不是一个数字，但是是 number 数字类型，<code>NaN==NaN</code>的值是<code>false</code></li><li>快速转换：字符串类型的数字，如果前面放 + 会隐式调用 parseFloat</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;123&quot;</span>); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;123&quot;</span>); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;a&quot;</span>, <span class="literal">false</span>]); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object  null时一个空指针，是一个对象，所以返回的值为boject</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">//function function是一个方法，是可调用对象，所以也是object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">//string 主要特别注意的是typeof本身返回的值是string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>); <span class="comment">//number  NaN是数字类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="built_in">isNaN</span>); <span class="comment">//boolean isNAN是boolean，用于判断对象是否是数字类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">null</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">undefined</span>)); <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Number</span>(<span class="string">&quot;我爱祖国和人民&quot;</span>)); <span class="comment">//number number()将其他类型转换为数字类型</span></span><br><span class="line"><span class="comment">// Number()返回的值有两种，一种是数字本身，一种是NaN，都是number数字类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="number">132</span>)); <span class="comment">//132</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;我爱祖国和人民11&quot;</span>)); <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;我爱祖国11&quot;</span>)); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;132我爱祖国11&quot;</span>)); <span class="comment">//132 parseInt只对字符串进行从左到右的查找输入匹配的数字，遇到非数字及终止</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="built_in">parseInt</span>(<span class="string">&quot;我爱祖国11&quot;</span>)); <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> +<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);</span><br><span class="line"></span><br><span class="line">变量没有datatype, 只有变量的值才有datatype;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num); <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name); <span class="comment">//string</span></span><br></pre></td></tr></table></figure><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul><li><p>由 0-16 位 unicode 字符组成；引用时需要使用’’或者””,但不能’、”交叉使用</p></li><li><p>.length 属性用于计算字符串长度，不能精确计算字节！</p></li><li><p>转义字符使用\表示</p></li><li><p>类型转换： <code>toString()</code> 、 <code>String()</code> 、<code>eval()</code></p></li><li><p>null 和 undefined 没有 toString 方法，所以转换的时候用<code>String()</code>函数</p></li><li><p>注意<code>.toString()</code>是个合法的方法，而<code>.String()</code>却不是</p></li><li><p>快速转换：如果把某个数据转化为字符串，可以有一个快捷的方式，就是把它与一个字符串 “” 相加就可以了；</p></li><li><p>运算 + - * &#x2F; % (取余) &#x3D; 等</p></li><li><p>内置属性</p><blockquote><p><b> <u>属性用<code>.</code>表示，方法用 <code>( )</code> 表示</u></b></p></blockquote><p>length</p><ul><li>String length 字符串长度</li><li>String slice() 字符串切片（）</li><li>String substring() 字符串子字符串（）</li><li>String substr() 字符串 substr（）</li><li>String replace() 字符串替换（）</li><li>String replaceAll() 字符串替换全部（）</li><li>String toUpperCase() 字符串到大写（）</li><li>String toLowerCase() 字符串到小写（）</li><li>String concat() 字符串 concat（）</li><li>String trim() 字符串修剪（）</li><li>String trimStart() 字符串修剪开始（）</li><li>String trimEnd() 字符串修剪结束（）</li><li>String padStart() 字符串 padStart（）</li><li>String padEnd() String padEnd（）</li><li>String charAt() 字符串字符（）</li><li>String charCodeAt() 字符串字符代码（）</li><li>String split() 字符串拆分（）</li></ul></li><li><p>String Concatenation(字符串拼接)</p><ul><li>使用字符串拼接操作符 <code>+</code> 将变量和字符串连接<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const name</span> = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="attribute">const age</span> = 25;</span><br><span class="line"><span class="attribute">const message</span> = <span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot; and I am &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Template Strings (字符串模板)</p><ul><li>将变量、表达式插入到字符串的语法（syntanx)为：${……}<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let</span> firstName = <span class="string">&quot;asdf&quot;</span>;</span><br><span class="line"><span class="attribute">let</span> <span class="literal">last</span>Name = <span class="string">&quot;wer&quot;</span>;</span><br><span class="line"><span class="attribute">let</span> name = <span class="string">&quot;<span class="variable">$&#123;firstName&#125;</span>  <span class="variable">$&#123;lastName&#125;</span>&quot;</span>;</span><br><span class="line"><span class="attribute">let</span> name1 = firstName + <span class="string">&quot; &quot;</span> + <span class="literal">last</span>Name</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;123我爱祖国和人民&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;123我爱祖国和人民&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str5 = <span class="string">&quot;function()&#123;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str6 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> str7 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//  上面都是合法的string类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str1); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str2); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str3); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str4); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str5); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str5.<span class="property">length</span>); <span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str4.<span class="property">length</span>); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str6.<span class="title function_">toString</span>()); <span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toString</span>(str6)); <span class="comment">//bojcet undefinde    这里会抛出一个TypeError，因为toString()是一个方法(method)不能当作函数(function)来调用。</span></span><br><span class="line"><span class="comment">// console.log(str6.String());   //123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(str6)); <span class="comment">//123   使用String()进行类型转换时，String()是一个函数(function)，不能当作方法(method)来使用。 当使用String()用来构造一个函数时才能当作方法来使用比如： const srt = new String(&quot;hello world&quot;)</span></span><br><span class="line"><span class="comment">// console.log(str6.String());   这是个不错误的用法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str6); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (str6 + <span class="string">&quot;&quot;</span>)); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str7); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> +str7); <span class="comment">//number</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><ul><li><p>boolean: true false</p><ul><li>true:true 本身、任何非空字符串、任何非零数值、对象(object)</li><li>false:false 本身、空字符串、0、NaN、null、undefined</li></ul></li><li><p>！（取反）与！！（取反再取反）</p></li></ul><hr><h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><ul><li>对象（object）是一种复合数据结构，用于存储和组织相关数据和功能，对象有方法和属性组成，属性表示对象的特征或状态，方法表示对象的执行或操作。</li><li>对象有键值对（properties）组成的结合，每个键值对包含一个属性名和对应的值，属性名通常是字符串，但也可以是数字和符号，值可以是任意的数据类型，包含对象、数组、正则、data 等，表示的是一组数据或者功能的集合，本质是个集合</li><li>对像的属性可以通过点表示法（object.property）或方括号表示法（object[‘property’]）进行访问</li><li>对象可以动态的添加、修改或者删除属性和方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; and I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot; years old.&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 访问属性，输出 &quot;Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&quot;age&quot;</span>]); <span class="comment">// 访问属性，输出 25</span></span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHello</span>(); <span class="comment">// 调用方法，输出 &quot;Hello, my name is Alice and I&#x27;m 25 years old.&quot;</span></span><br><span class="line">person.<span class="property">gender</span> = <span class="string">&quot;Female&quot;</span>; <span class="comment">// 添加属性</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">26</span>; <span class="comment">// 修改属性</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span>; <span class="comment">// 删除属性</span></span><br></pre></td></tr></table></figure><ul><li><p>null undefined</p></li><li><p>Symbol</p></li><li><p>BingInt</p></li><li><p>属性（property）和方法(method)的区别</p><ul><li>属性<ul><li>属性和方法都是对象(object)的成员，但它们的作用和使用方式略有不同。</li><li>属性（property）是对象的值(特性或状态)，用于存贮或者表示对象的状态。可以通过对象的名称和属性名来访问。对象属性通常用于存储对象的状态或特征。 例如:一个人对象可能有属性名为“姓名”、“年龄”、“性别”等，用于描述这个人的基本信息。</li><li>属性（property）具有与之相关的值，可以是任何 JavaScript 数据类型，包括字符串、数字、布尔、对象等。</li><li>属性可以通过点表示法（object.property）或者方括号表示法（object[‘property’]）来访问和修改</li></ul></li><li>方法<ul><li>方法(method)是对象的函数，是对象的行为和操作，用于定义对象的功能，通常是对象的函数成员，用于执行特定的动作或操作。可以在对象上调用。<br>例如，一个人对象可能有方法名为“说话”、“走路”、“睡觉”等，用于描述这个人的行为或动作。方法可以访问和修改对象的属性，也可以返回值。</li><li>方法(Method)包含一系列的语句和算法，可以接受函数并返回结果。</li><li>方法(Method)需要通过对象调用来执行，使用点表示法（object.method()）或者方括号表示法（object[‘method’]），在方法的内部，使用<code>this</code>关键字来引用当前对象，可以访问对象的属性和其他方法。</li></ul></li><li>区别<ul><li>属性描述对象的特征或状态，而方法描述对象的行为或操作</li><li>属性存储值，方法执行操作</li><li>属性可以直接访问和修改，而方法需要通过对象调用执行</li><li>方法可以修改对象的属性值，但属性不能执行任何操作，只能被读取或赋值。</li></ul></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">  假设我们有一辆汽车，它有许多属性和方法：</span><br><span class="line"></span><br><span class="line">  属性：车牌号、颜色、品牌、型号、车速等。这些属性描述了汽车的状态或特征，它们的值可以被读取和设置，但它们并不会对汽车本身产生任何影响。</span><br><span class="line"></span><br><span class="line">  方法：加速、刹车、转弯、打开车窗、打开收音机等。这些方法描述了汽车的行为或动作，它们会对汽车本身产生影响，例如加速会使汽车前进，刹车会使汽车停止。</span><br><span class="line"></span><br><span class="line">  因此，属性和方法的区别在于它们描述了汽车的不同方面：属性描述了汽车的状态或特征，而方法描述了汽车的行为或动作。属性可以被读取和设置，但不会对汽车本身产生任何影响；方法可以对汽车产生影响，例如改变汽车的速度或位置</span><br></pre></td></tr></table></figure></li><li><p>方法(method)和函数(function)的区别</p><ul><li><p>方法(method)</p><ul><li>方法和函数都可以被调用，但它们的调用方式略有不同。</li><li>方法是一个对象的属性，是对象的行为和操作，定义在对象中，通过对象进行调用。</li><li>方法是与对象关联的，可以使用对象内部的数据和其他方法</li><li>方法(Method)需要通过对象调用来执行，使用点表示法（object.method()）或者方括号表示法（object[‘method’]），在调用时会自动绑定到对象上，在方法的内部，使用<code>this</code>关键字来引用当前对象，可以访问对象的属性和其他方法。</li></ul></li><li><p>函数（function）</p><ul><li>函数是 JavaScript 中的一等公民，是一段独立的可重复用的代码块，可以在任何地方定义和调用，可以接受参数并返回值。当调用一个函数时，只需要使用函数名和一对圆括号来调用它</li><li>函数是独立的，没有与之直接关联的对象</li><li>函数的上下文（context）取决于它被调用的方式，可以是全局对象，也可以是调用时所指定的对象</li><li>函数的调用通过函数名跟一对括号<code>function( )</code>来完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法示例</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">method</span>(); <span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类比：</span><br><span class="line">  使用一个人类的身体来类比下方法和函数的区别。</span><br><span class="line"></span><br><span class="line">  我们的身体有许多不同的器官，例如心脏、肺、胃等。每个器官都有自己独特的功能，可以帮助我们完成不同的任务。</span><br><span class="line"></span><br><span class="line">  方法就像是身体的器官，它们属于身体的某个部分，并且可以完成该部分的特定任务。例如，心脏可以将血液循环到身体的各个部分，它就像是身体的某个部分的方法，可以完成该部分的特定任务。当我们想要使用身体的某个器官时，需要先找到它所在的部位（对象），然后使用该器官（调用该对象的方法）。</span><br><span class="line"></span><br><span class="line">  函数就像是身体的整体健康状况，它们是独立的代码块，可以实现特定的功能。例如，锻炼可以提高身体的健康状况，它就像是一个函数，可以实现特定的功能。当我们想要改善身体的健康状况时，可以根据医生或运动教练的建议来进行锻炼（调用该函数），然后根据锻炼计划来进行运动。</span><br><span class="line"></span><br><span class="line">  因此，方法和函数的区别可以类比为身体的器官和整体健康状况的区别。方法属于身体的某个部分，可以完成该部分的特定任务；函数是独立的代码块，可以实现特定的功能。</span><br></pre></td></tr></table></figure></li><li><p>变量（variable）</p><ul><li><p>变量（varibale）是用于存储和引用数据的命名容器，允许在程序中保存数据，并在需要时对其进行访问和操作&#x2F;修改。变量是数据值（values）的容器容器（containers）</p></li><li><p>变量的使用</p><ul><li><p>变量的声明（declaration）</p><ul><li>变量在使用之前需要先声明，声明变量意味着创建一个具有指定名称的变量，并为其分配内存空间。</li><li>var 旧版本的声明方式，在块内声明的 var 变量也会重新声明其对应的块外的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li>const 用於声明定义一个常量的变量，后续不能重新赋值。常用于声明一些不可变的变量，只读变量，比如出生日期 等,不能被重新赋值（unreassign),也具备块作用域（block scope)</li><li>let 不能被重复声明（redelared)的变量,必须在使用前声明，具有块范围（block scope）,可以被重新赋值（reassign）</li></ul></li><li><p>变量的命名</p><ul><li>组成：<br>字母、数字、下划线，不能以数字开头</li><li>变量名区分大小写</li><li>习惯用发为第二个单词开始大写即驼峰命名法（camelCase），或者单词间用_连接即下划线命名法（snake_case）。</li><li>保留关键字不可用做变量名，注意 name 比较特殊，但一般不建议做变量名使用。</li><li>选择能够描述变量用途的名称。</li><li>使用有意义的单词或单词组合，避免使用缩写、简写、无意义的组合</li><li>建议使用名字表示对象，变量名应该反应变量所表示的概念。</li><li>避免命名的歧义，避免使用容易混淆的变量名，确保容易被理解。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let x = 2; // Identifier &#x27;x&#x27; has already been declared,不能被重新声明</span></span><br><span class="line">  x = <span class="number">2</span>; <span class="comment">// 2 可以被重新赋值（reassign)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10 ，注意这里因为作用域不同，块内let x = 1 在块外不起任何作用，所有不会报错重复声明。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">//x undefined 。具有块作用域block scope</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const x = 2; // Identifier &#x27;x&#x27; has already been declared,不能被重新声明</span></span><br><span class="line">  x = <span class="number">2</span>; <span class="comment">// Assignment to constant variable.const不可以被重新赋值（unreassign)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10 ，注意这里因为作用域不同，块内const x = 1 在块外不起任何作用，所有不会报错重复声明。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">//x undefined 。具有块作用域block scope</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数（funciton）</p><ul><li>用于执行特定功能的可重复使用的代码块，用于执行特定的任务或操作，函数将一系列的语句组合在一起，并通过给定的输入（参数）来执行特定的计算或操作，并返回一个结果。</li><li>函数可以有任意数量的参数，也可以没有参数，参数可以有默认值，也可以通过参数的位置或名称进行传递。</li><li>特点 &gt; 高内聚、低耦合、复用、多态 - 封装性<br>函数将一段代码封装在内部，形成一个独立的执行单元，这样可以提高代码的可重复性和模块化 - 参数<br>sum&#x2F;&#x2F; 函数可以接受输入参数，这些参数是函数运行时提供的值。参数可以用于函数内部的计算和操作。 - 返回值<br>函数可以返回一个值作为结果，返回值可以用于将函数的计算结果传递给调用者。 - 格式<br>function functionName(argument1,argument2,……){ &#x2F;执行语句&#x2F; } - return 语句可以不带任何返回值，这时 return 的返回值时 undefined，一般用于需要提前停止函数又不用返回值的情况 - 在被调用（call &#x2F; invoke）时才执行。<br>函数的调用(call):函数名（）<br>&#96;javascript<br>function sum(a, b) {<br>if (a &gt; b) {<br>return (a - b);<br>}<br>else {<br>return (b - a); &#x2F;&#x2F;函数的返回值只能通过 return 返回，遇到执行 teturn 的代买以后函数就会终止，return 以后的语句不会被执行。一个函数可以有多个 return.<br>}<br>}<br>const mat1 &#x3D; sum(15, 2); &#x2F;&#x2F; 函数的调用(call):函数名（）<br>const mat2 &#x3D; sum(2, 15);<br>const mat3 &#x3D; sum; &#x2F;&#x2F; 调用不带（）的函数返回的时函数本身，而不是返回函数的运算值；<br>console.log(mat1, “ “, mat2); &#x2F;&#x2F;17 &#x2F;&#x2F; 函数的调用(call):函数名（）<br>console.log(mat3); &#x2F;&#x2F; 返回函数本身</li><li>箭头函数 （arrow function）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum2</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum2</span>(<span class="number">15</span>, <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum2</span>(<span class="number">2</span>, <span class="number">14</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum2</span>());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象 object<br>&#x2F;&#x2F; 属性（properte)和方法（method）的集合，而变量是数据的容器，所以对象也是变量，只是包含了更多的值。</p></li></ul><p>&#x2F;&#x2F; const car &#x3D; {<br>&#x2F;&#x2F; type: “fiat”, &#x2F;&#x2F;注意对象的属性用，分割（不是；）<br>&#x2F;&#x2F; modle: “x”,<br>&#x2F;&#x2F; color: “white” &#x2F;&#x2F; 对象的最后一个字面量的结尾是不需要 ， 的，如果加了，加的，会被解释成一个额外的属性，其属性名是个空的字符串，属性值是 undefined。<br>&#x2F;&#x2F; }; &#x2F;&#x2F;要特别注意这个；不能省略<br>&#x2F;&#x2F; console.log(car.type); &#x2F;&#x2F;用对象名.属性名来访问属性值。<br>&#x2F;&#x2F; console.log(car[‘type’]); &#x2F;&#x2F; 另一种访问属性值的方法，注意 car[‘type’]和 car[“type”]效果是相同的， string 可以是用””，也可以使用’’</p><p>&#x2F;&#x2F; 对象的三种创建方式：<br>&#x2F;&#x2F; 使用 对象字面量 object literal;<br>&#x2F;&#x2F; 注意对象的属性赋值用的是：而是不是&#x3D;<br>&#x2F;&#x2F; &#x2F;&#x2F; 等同于 const person &#x3D; {name: “Leon”,age: 18,city:”HeNan”};<br>&#x2F;&#x2F; const person &#x3D; {<br>&#x2F;&#x2F; name : “Leon”,<br>&#x2F;&#x2F; age : 18, &#x2F;&#x2F;属性值以：赋值，属性间用，分隔<br>&#x2F;&#x2F; city : “HeNan” &#x2F;&#x2F;最后一个属性结尾没有符号<br>&#x2F;&#x2F; };</p><p>&#x2F;&#x2F; console.log(person.name); &#x2F;&#x2F;Leon</p><p>&#x2F;&#x2F; 使用 new Object()创建<br>&#x2F;&#x2F; const person &#x3D; new Object();<br>&#x2F;&#x2F; person.name &#x3D; “Leon”;<br>&#x2F;&#x2F; person.age &#x3D; 18;<br>&#x2F;&#x2F; person.city &#x3D; “HeNan”;<br>&#x2F;&#x2F; console.log(person.name); &#x2F;&#x2F;Leon</p><p>&#x2F;&#x2F; 使用 构造函数 constrator<br>&#x2F;&#x2F; function person(name , age , city){<br>&#x2F;&#x2F; this.name &#x3D; “Leon”;<br>&#x2F;&#x2F; this.age &#x3D; 18;<br>&#x2F;&#x2F; this.city &#x3D; “HeNan”;<br>&#x2F;&#x2F; };</p><p>&#x2F;&#x2F; const person1 &#x3D; new person(‘Leon’ , 18 , ‘HeNan’); &#x2F;&#x2F;使用 new 调用构造函数 person 创建对象，将返回值再赋值给变量 person1;<br>&#x2F;&#x2F; console.log(person1.name) &#x2F;&#x2F;Leon</p><p>&#x2F;&#x2F; 使用 Object.create()<br>&#x2F;&#x2F; 首先定义一个原型对象<br>&#x2F;&#x2F; const personPrototype &#x3D; { &#x2F;&#x2F;定义一个名字为 personPrototype 的原型对象<br>&#x2F;&#x2F; sayHi: function(){ &#x2F;&#x2F;原型对象的一个名为 sayHi 的方法<br>&#x2F;&#x2F; console.log(“你好，我的名字是” + this.name);<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; };<br>&#x2F;&#x2F; const person1 &#x3D; Object.create(personPrototype); &#x2F;&#x2F;使用 Objcet.crate()方法创建的对象会继承原型对象的属性和方法。<br>&#x2F;&#x2F; person1.name &#x3D; “Leon”;<br>&#x2F;&#x2F; console.log(person1.name); &#x2F;&#x2F; Leon<br>&#x2F;&#x2F; person1.sayHi(); &#x2F;&#x2F; 你好，我的名字是 Leon</p><p>&#x2F;&#x2F; 访问对象属性名称（key）和值(values)的方法</p><p>&#x2F;&#x2F; const person &#x3D; {<br>&#x2F;&#x2F; name: “Leon”,<br>&#x2F;&#x2F; age: 18,<br>&#x2F;&#x2F; &#x2F;&#x2F; x: “d”<br>&#x2F;&#x2F; };<br>&#x2F;&#x2F; let info &#x3D; “”;<br>&#x2F;&#x2F; for (const key in person) {<br>&#x2F;&#x2F; console.log(<code>$&#123;key&#125; : $&#123;person[key]&#125;</code>); &#x2F;&#x2F; 这里使用字符串模板语法也叫模板字面量，用&#96;&#96;表示，可以在字符串中插入变量、函数调用等<br>&#x2F;&#x2F;   &#x2F;&#x2F;info +&#x3D; <code>$&#123;key&#125; : $&#123;person[key]&#125;</code>+”\n”<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; console.log(info);</p><p>&#x2F;&#x2F; const myArrary &#x3D; Object.keys(person); &#x2F;&#x2F; 使用 Object.keys()\ Object.values() 将对象 person 转换为数组<br>&#x2F;&#x2F; console.log(myArrary);</p><p>&#x2F;&#x2F; let info2 &#x3D; “”;<br>&#x2F;&#x2F; for (let x in person) {<br>&#x2F;&#x2F; info2 +&#x3D; x + “:” + person[x] + “\n” + person.x &#x2F;&#x2F; x 代表 person 对象的属性，person[]代表属性值,注意这里 person[x]代表属性值，而 preson.x 不起作用因为 x 是一个变量,如果碰巧 person 对象里有名字为“x”的属性，则输出其值。<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; console.log(info2);</p><p>&#x2F;_ arguments 对象 _&#x2F;</p><p>&#x2F;&#x2F; argument(形参) 用于描述（在函数内）期望被提供的值的名字<br>&#x2F;&#x2F; parameter(实参) 用于描述（调用函数时）提供给每个形参的值</p><p>&#x2F;* 运算符<br>&#x2F;&#x2F; let num1&#x3D;3;<br>&#x2F;&#x2F; console.log(num1++); &#x2F;&#x2F;3<br>&#x2F;&#x2F; console.log(num1); &#x2F;&#x2F;4</p><p>&#x2F;&#x2F; let num2&#x3D;3;<br>&#x2F;&#x2F; console.log(++num2); &#x2F;&#x2F;4<br>&#x2F;&#x2F; console.log(num2); &#x2F;&#x2F;4</p><p>&#x2F;&#x2F; var num&#x3D;0;<br>&#x2F;&#x2F; num&#x3D;num+2; &#x2F;&#x2F;2<br>&#x2F;&#x2F; num&#x3D;num<em>3; &#x2F;&#x2F;6<br>&#x2F;&#x2F; num&#x3D;num&#x2F;2; &#x2F;&#x2F;3<br>&#x2F;&#x2F; num++; &#x2F;&#x2F;3<br>&#x2F;&#x2F; num–; &#x2F;&#x2F;<br>&#x2F;&#x2F; console.log(num);<br>&#x2F;&#x2F; num+&#x3D;1;<br>&#x2F;&#x2F; console.log(num);<br>&#x2F;&#x2F; num-&#x3D;2;<br>&#x2F;&#x2F; console.log(num);<br>&#x2F;&#x2F; num</em>&#x3D;3;<br>&#x2F;&#x2F; console.log(num);<br>&#x2F;&#x2F; num&#x2F;&#x3D;2;<br>&#x2F;&#x2F; console.log(num);<br>&#x2F;&#x2F; num%3;<br>&#x2F;&#x2F; console.log(num);</p><p>&#x3D; （赋值）&#x3D;&#x3D;（相等） 与 &#x3D;&#x3D;&#x3D;（恒等），</p><p>对象运算符<br>In 判断左侧运算数是否是右侧运算数的成员<br>Instancesof 判断这个实例是否属于某个类或者构造函数<br>New 根据构造函数插件一个新的对象，并进行初始化<br>Delete 删除指定对象的属性、数组元素或者变量<br>. [] 存取对象和数组元素</p><p>*&#x2F;</p><p>&#x2F;_ 流程语句<br>&#x2F;_ 循环语句 跳转语句<br>&#x2F;&#x2F; 循环语句 ：<br>&#x2F;&#x2F; do{ &#x2F;&#x2F; 执行代码 }while(条件表达式)；<br>&#x2F;&#x2F; while(条件表达式){ &#x2F;&#x2F; 执行代码 }<br>&#x2F;&#x2F; for(循环变量&#x3D;初始值；循环条件；递增&#x2F;减计算器){ &#x2F;&#x2F;执行代码 }<br>&#x2F;&#x2F; for(声明变量 in 对象){&#x2F;&#x2F; 执行代码}</p><pre><code>  // 跳转语句    // return  运行return以后及跳出并终止函数，return以后的代码不会执行。    // break  终止并跳出当前循环。    // continue 终止并跳回到条件判断继续执行循环，直至判断条件为false结束循环。    let a = 3 ;        b = 1 ;    // do&#123;    //   console.log(a + b);    //   continue;   //结束本次循环，然后去判断是否实行下次循环    //   console.log(a -b);    //   break; // 终止循环，不再进行判断    // &#125;while(a &gt; b);    while(a &gt; b)&#123;      console.log(a + b);      b++;      // continue;      break;    &#125;*/</code></pre><p>&#x2F;* 选择语句</p><p>&#x2F;&#x2F; if(条件表达式 1){<br>&#x2F;&#x2F; &#x2F;&#x2F; 执行代码;<br>&#x2F;&#x2F; }else if(条件表达式 2){<br>&#x2F;&#x2F; &#x2F;&#x2F; 执行代码 2;<br>&#x2F;&#x2F; }else{<br>&#x2F;&#x2F; &#x2F;&#x2F; 执行代码 3;<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; switch(条件表达式){<br>&#x2F;&#x2F; case 标签 1： &#x2F;&#x2F;case 是一个常量,可以是字符串或数字,每一个标签后面需要以: 结束<br>&#x2F;&#x2F; &#x2F;&#x2F; 执行代码 1;<br>&#x2F;&#x2F; break;<br>&#x2F;&#x2F; …<br>&#x2F;&#x2F; Default:<a href=""></a><br>&#x2F;&#x2F; &#x2F;&#x2F; 执行代码 n;<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; let a&#x3D;6;<br>&#x2F;&#x2F; b&#x3D;6;</p><p>&#x2F;&#x2F; if(a&gt;b){<br>&#x2F;&#x2F; console.log(a-b);<br>&#x2F;&#x2F; }else if(a&#x3D;&#x3D;b){<br>&#x2F;&#x2F; console.log(‘a: ‘+ a + ‘, b: ‘+b)<br>&#x2F;&#x2F; }else{<br>&#x2F;&#x2F; console.log(b-a)<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; switch(a-b){<br>&#x2F;&#x2F; case 0:<br>&#x2F;&#x2F; console.log(a-b);<br>&#x2F;&#x2F; break;<br>&#x2F;&#x2F; case 1:<br>&#x2F;&#x2F; console.log(a-b)<br>&#x2F;&#x2F; break;<br>&#x2F;&#x2F; Default:<a href=""></a><br>&#x2F;&#x2F; }<br><em>&#x2F;<br>&#x2F;</em> 异常处理语句<br>throw 主动抛出异常<br>try 指明需要处理的代码段<br>catch 捕获异常<br>finally 后期处理，无论是否有错误，都会执行<br>*&#x2F;</p><p>&#x2F;_ 其他语句_&#x2F;<br>&#x2F;&#x2F; debugger 调用任何咳哟个的调试功能，没有调试功能是该语句不起作用<br>&#x2F;&#x2F; export<br>&#x2F;&#x2F; import</p><p>&#x2F;* 对象、实例、类、函数、数据类型和方法<br>在 JavaScript 中，对象、实例、类、函数、数据类型和方法是不同的概念，它们有着各自的含义和用途。</p><p>对象：对象是属性和方法的集合。在 JavaScript 中，几乎所有东西都是对象，包括字符串、数字、数组、函数、对象等。<br>类比：对象就像一台汽车，它由各种部件组成，比如发动机、轮胎、座椅等。每个部件都有它自己的属性，比如发动机有汽缸数、排量、功率等属性，轮胎有尺寸、胎压等属性。</p><p>实例：实例是通过类创建的对象。每个实例都具有类定义的属性和方法。在 JavaScript 中，使用 new 关键字创建实例。<br>类比：实例就像一辆具体的汽车，它是由汽车工厂根据设计图纸生产出来的。每辆汽车都具有相同的属性和方法，比如同一款车型的汽车都有相同的发动机、轮胎、座椅等。</p><p>类：类是一种用于创建对象的模板。在 JavaScript 中，类可以使用构造函数、类声明和类表达式来定义。<br>类比：类就像汽车工厂，它定义了汽车的基本设计图纸，并且能够根据设计图纸生产出具体的汽车。</p><p>函数：函数是一种可执行的代码块，可以接受参数并返回值。在 JavaScript 中，函数可以用来执行一些操作或计算。<br>类比：函数就像汽车的驾驶员，它可以控制汽车的运行，比如加速、刹车、转向等。</p><p>数据类型：数据类型指的是 JavaScript 中的基本数据类型，包括字符串、数字、布尔值、null 和 undefined。<br>类比：数据类型就像汽车的零部件，它们是汽车运行的基本构成单元，比如汽车需要发动机、轮胎等部件才能正常行驶。</p><p>字面量（Literal）是指表示特定数据类型的常量值，它是程序中直接出现的数据值，而不是由变量、函数或表达式计算得出的值。字面量可以表示各种不同的数据类型，例如字符串、数字、布尔值、数组、对象等。</p><p>方法：方法是对象中的函数，是可以对对象执行的操作。在 JavaScript 中，方法是对象的属性，其值为函数。<br>类比：方法就像汽车的功能，比如汽车可以加速、刹车、转向等。每个汽车都具有相同的功能，但具体实现可能有所不同。<br>属性：对象中的命名值成为属性 property ,属性的值为 value</p><p>综上所述，可以用汽车来类比解释对象、实例、类、函数、数据类型和方法的概念。汽车工厂就是类，设计图纸就是对象模板，每辆汽车就是实例，驾驶员就是函数，零部件就是数据类型，而汽车的功能就是方法。<br>*&#x2F;</p><p>&#x2F;&#x2F; 事件 Event<br>&#x2F;&#x2F; 对 html 元素（elements）进行的操作,当 javascript 用于 html 时，这些事件 event 可以运行对应的 JavaScript<br>&#x2F;&#x2F; 常见的用法是通过 事件 调用函数</p><p>&#x2F;&#x2F; 典型的事件有，参见 html dom events：<br>&#x2F;&#x2F; onchange<br>&#x2F;&#x2F; onclick<br>&#x2F;&#x2F; onmouseover<br>&#x2F;&#x2F; onmouseout<br>&#x2F;&#x2F; onload</p><p>&#x2F;_ 类 class_&#x2F;<br>&#x2F;&#x2F; 类 class 是对象 object 的模板,注意类不是一个对象<br>&#x2F;&#x2F; class ClassName {<br>&#x2F;&#x2F; constructor(){……}<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; 使用类：<br>&#x2F;&#x2F; class Car {<br>&#x2F;&#x2F; constructor(name,year){<br>&#x2F;&#x2F; this.name &#x3D; name;<br>&#x2F;&#x2F; this.year &#x3D; year;<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; const myCar1 &#x3D; new Car(“Hoda”, 2017);<br>&#x2F;&#x2F; console.log(myCar1.name); &#x2F;&#x2F;Hoda<br>&#x2F;&#x2F; console.log(myCar1.year); &#x2F;&#x2F;2017</p><p>&#x2F;&#x2F; 创建新的对象 object 时会自动调用（call）构造函数方法（constructor method）；<br>&#x2F;&#x2F; 如果不定义构造函数方法，会自动添加一个空的构造函数方法；</p><p>&#x2F;&#x2F; 类方法<br>&#x2F;&#x2F; class ClassName {<br>&#x2F;&#x2F; constructor() { … } &#x2F;&#x2F;构造函数方法 constructor method<br>&#x2F;&#x2F; method_1() { … } &#x2F;&#x2F;类方法 class method<br>&#x2F;&#x2F; method_2() { … }<br>&#x2F;&#x2F; method_3() { … }<br>&#x2F;&#x2F; }</p><p>&#x2F;&#x2F; JSON<br>&#x2F;&#x2F; 存储和传输数据的格式，主要用于网页请求。<br>&#x2F;&#x2F; 数据存在 键 key&#x2F;值 value 中，名字和值是配对出现的,单个数据样式为 “key”:”value”，<br>&#x2F;&#x2F; 各数据以，分隔；<br>&#x2F;&#x2F; 所有数据用{}包围；<br>&#x2F;&#x2F; 数据中[]表示数组；</p><p>&#x2F;&#x2F; 将 json 转换为 javascript 对象<br>&#x2F;&#x2F; let text &#x3D; ‘ json 字符串’; &#x2F;&#x2F; 将 json 字符串存储到一个变量里<br>&#x2F;&#x2F; const obj &#x3D; JSON.parse(text); &#x2F;&#x2F; 将 json 字符串转化为 JavaScript 对象。JSON.parse()是 JavaScript 的内置函数,用于将 JSON 转换为对象</p><p>&#x2F;&#x2F; const myJSON &#x3D; ‘{“name”:”John”, “age”:30, “cars”:[“Ford”, “BMW”, “Fiat”]}’;<br>&#x2F;&#x2F; const myObj &#x3D; JSON.parse(myJSON);<br>&#x2F;&#x2F; let a &#x3D; “”;<br>&#x2F;&#x2F; for (const x in myObj.cars) {<br>&#x2F;&#x2F; a +&#x3D; myObj.cars[x];<br>&#x2F;&#x2F; };<br>&#x2F;&#x2F; console.log(a); &#x2F;&#x2F;FordBMWFiat</p><p>&#x2F;&#x2F; console.log(myObj.cars[2]); &#x2F;&#x2F;Fiat</p><p>&#x2F;&#x2F; for (const y in myObj) {<br>&#x2F;&#x2F; const val &#x3D; <code>$&#123;y&#125;</code> + “ : “ + <code> $&#123;myObj[y]&#125;</code>;<br>&#x2F;&#x2F; console.log(val); &#x2F;&#x2F; name : John age : 30 cars : Ford,BMW,Fiat<br>&#x2F;&#x2F; };</p><p>&#x2F;&#x2F; const cKey &#x3D; Object.keys(myObj);<br>&#x2F;&#x2F; const cArray &#x3D; Object.values(myObj);<br>&#x2F;&#x2F; console.log(cKey[2]); &#x2F;&#x2F;cars<br>&#x2F;&#x2F; console.log(cArray[2]); &#x2F;&#x2F;[ ‘Ford’, ‘BMW’, ‘Fiat’ ]</p><p>&#x2F;&#x2F; 代码风格</p><p>&#x2F;&#x2F; 变量名称 Variable Name<br>&#x2F;&#x2F; 1.使用 camelCase 作为标识符(identifier names)（变量 cariables 和函数 functions）<br>&#x2F;&#x2F; camelCase （驼峰） 以小写字母开头，后续的单词首字母大写<br>&#x2F;&#x2F; 2.在运算符（Operators)（ &#x3D; + - * &#x2F; ）的后面放空格<br>&#x2F;&#x2F; 3.使用两个空格缩进代码块（不适用制表符进行缩进）<br>&#x2F;&#x2F; 4.以；结束简单语句，复合语句后面不跟；<br>&#x2F;&#x2F; 复杂（复合）的语句一般：将左阔行放在第一行的末尾，在左括号签放一个空格，将右括号放在新行，不带前导空格，不以；结束复杂语句（复合语句）。复合语句（compound satement）主要包括函数体（function body）\ 添加语句体（if statement body） \ 循环语句体（loop statement body）</p><p>&#x2F;&#x2F; 全局变量 global variable<br>&#x2F;&#x2F; 使用大写</p><p>&#x2F;&#x2F; , 与 ；的用法区别<br>&#x2F;&#x2F; 都是用于分隔语句的符号。<br>&#x2F;&#x2F; ，用于分隔表达式（expression），可以在一个语句中包含多个表达式<br>&#x2F;&#x2F; ；用于分隔语句(statement)，用于表示一个语句的结束</p><p>&#x2F;&#x2F; 表达式（expression）与语句(statement)的用法区别<br>&#x2F;&#x2F; 1.返回值<br>&#x2F;&#x2F; 表达式：执行结果后返回一个值<br>&#x2F;&#x2F; 语句：执行结果只是改变程序状态或控制流程，不返回值<br>&#x2F;&#x2F; 2.赋值<br>&#x2F;&#x2F; 表达式：可以作为赋值语句的右值<br>&#x2F;&#x2F; 语句：不能在赋值语句中使用<br>&#x2F;&#x2F; 3.独立存在<br>&#x2F;&#x2F; 表达式可以独立存在<br>&#x2F;&#x2F; 语句需要在函数体、流程语句中才能存在，不能独立存在</p>]]></content>
      
      
      
        <tags>
            
            <tag> javasScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppleStore内购破解的一种思路</title>
      <link href="/2023/10/02/AppleStore%E5%86%85%E8%B4%AD%E7%A0%B4%E8%A7%A3%E7%9A%84%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/10/02/AppleStore%E5%86%85%E8%B4%AD%E7%A0%B4%E8%A7%A3%E7%9A%84%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="此前，采用过提起-adbk-文件还原应用，再利用-imzaing-导出应用程序备份文件可以在不能安装-TrollStore-的设备上通过还原此备份文件，实现内购破解。"><a href="#此前，采用过提起-adbk-文件还原应用，再利用-imzaing-导出应用程序备份文件可以在不能安装-TrollStore-的设备上通过还原此备份文件，实现内购破解。" class="headerlink" title="此前，采用过提起 adbk 文件还原应用，再利用 imzaing 导出应用程序备份文件可以在不能安装 TrollStore 的设备上通过还原此备份文件，实现内购破解。"></a>此前，采用过提起 adbk 文件还原应用，再利用 imzaing 导出应用程序备份文件可以在不能安装 TrollStore 的设备上通过还原此备份文件，实现内购破解。</h3><p>今天在折腾 APtv 这个应用时发现，破解脚本在 1.2.6 上已经不能使用了，作者在新版本中禁止了 Mitm。<br>于是通过以下方式实现了 APtv 的内购破解“</p><h3 id="需要准备"><a href="#需要准备" class="headerlink" title="需要准备"></a>需要准备</h3><ul><li>一个已经购买过 APtv 的 appleid（大多数来源于共享账号）</li><li>一个自己常用的 appleid</li><li>手机上开启 icloud</li></ul><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>AppStore 登录购买过 APtv 的 appleid,下载 Aptv，此时 APtv 是 pro 状态</li><li>设置里打开 icloud,同步 Aptv 数据到该 icloud</li><li>对 aptv 做简单配置，填写一些源，以便 aptv 的应用数据能同步到 cloud，稍等片刻，确保已同步。</li><li>卸载 Aptv 后重新安装，再次打开如果发现前面配置的数据自动同步显示了，就可以再次卸载 Aptv 了。</li><li>退出 Appleid，登录自己常用的 appleid</li><li>下载 Aptv，打开等待 icloud 数据同步数据过来</li><li>未内购过的这个 Appleid 下载的 aptv 也是 pro 状态了，并且可以正常升级。</li></ul><h3 id="主要是采用-icloud-同步应用数据到-icloud-账户下，再次下载应用时-icloud-上的该应用数据包含内购信息能够正常同步到-APP，实现内购破解。"><a href="#主要是采用-icloud-同步应用数据到-icloud-账户下，再次下载应用时-icloud-上的该应用数据包含内购信息能够正常同步到-APP，实现内购破解。" class="headerlink" title="主要是采用 icloud 同步应用数据到 icloud 账户下，再次下载应用时 icloud 上的该应用数据包含内购信息能够正常同步到 APP，实现内购破解。"></a>主要是采用 icloud 同步应用数据到 icloud 账户下，再次下载应用时 icloud 上的该应用数据包含内购信息能够正常同步到 APP，实现内购破解。</h3><p>同理，部分其他 APP 同样可以采用此方式实现内购破解。等待更多测试，已确定具体机制。</p><p>突然理解到：所有支持使用脚本 一 次 性 解 锁 的软件都可以采用这个方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内购破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iso andorid windows mac TV 观看IPTV的解决方案</title>
      <link href="/2023/09/19/iso-andorid-windows-mac-TV-%E8%A7%82%E7%9C%8BIPTV%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/09/19/iso-andorid-windows-mac-TV-%E8%A7%82%E7%9C%8BIPTV%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="IPTV"><a href="#IPTV" class="headerlink" title="IPTV"></a>IPTV</h2><p>就是解决看电视频道的需求，实现步骤分两步：</p><ul><li>找到电视频道的可用的直播源文件，一般是 m3u、m3u8 格式，网络搜索或者自己抓包按格式编写均可；</li><li>找到一个合适的播放器打开直播预源文件即可。</li></ul><h2 id="直播源"><a href="#直播源" class="headerlink" title="直播源"></a>直播源</h2><p>网上有很多直播源，有一些是 iptv 抓包的数据，质量不一。<br>一个近来相对稳定的直播源：<a href="https://live.fanmingming.com/"> fanmignming </a> ，速度不错，源地址时常更新。</p><p>KODI 中文网也有 m3u 文件推荐。</p><h2 id="播放软件"><a href="#播放软件" class="headerlink" title="播放软件"></a>播放软件</h2><p>ios : ntPlayer（个人推荐）、VLC、kodi(需要侧载)等<br>andorid: KODI (个人推荐)、 IPTVpro、vlc 等<br>windows:PotPlayer（个人推荐）、KODI、vlc 等<br>mac:ntPlyaer(没错 store 里可以下载 iphone 版能正常使用)、vlc、kodi 等<br>Android TV：kodi(个人推荐，可设置启动页面为电视自动播放)，TV 端还有个 秒看 TV 的 APP 自带源速度也不错，注意不要下载到修改版本（有购物频道）注意甄别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iptv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac ftp只读的问题</title>
      <link href="/2023/09/19/mac-ftp%E5%8F%AA%E8%AF%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/19/mac-ftp%E5%8F%AA%E8%AF%BB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-的-FInder-中连接的-ftp-默认是只读模式，需要借助第三方-FTP-工具来实现-读写-权限！"><a href="#Mac-的-FInder-中连接的-ftp-默认是只读模式，需要借助第三方-FTP-工具来实现-读写-权限！" class="headerlink" title="Mac 的 FInder 中连接的 ftp 默认是只读模式，需要借助第三方 FTP 工具来实现 读写 权限！"></a>Mac 的 FInder 中连接的 ftp 默认是只读模式，需要借助第三方 FTP 工具来实现 读写 权限！</h2>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window忘记开机密码</title>
      <link href="/2023/09/16/window%E5%BF%98%E8%AE%B0%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81/"/>
      <url>/2023/09/16/window%E5%BF%98%E8%AE%B0%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>win11的开机密码有时间限制，会要求定期修改密码。今天在看到提醒以后，在登陆页面修改了下密码，修改以后使用新密码顺利登陆了账号，然后就在设置-账户管理修改了下密码，原本事项改回原来的密码这样方便，本身账号密码也没什么安全性要求。这个时候，异常出现了，密码死活不能登陆，新密码、旧密码都不能使用，均提示密码不正确。</p><p>手里又没有启动盘，于是找到了一个方法：</p><ul><li>shift+重启，进系统故障排除-高级选项 advanced options</li><li>进命令行模式 command promot<br> 网上找到的方法是直接就打开了 cmd , 但是我这里还是需要登陆管理员账号，还是需要输入管理员密码才能进入 command promot。<br> 此路不通 。</li></ul><p> 发现就是需要调用cmd 然后通过cmd命令，使用cmd替换辅助访问程序，达到在登陆页面调用cmd，才使用cmd修改用户密码的方法。</p><p> 突然想起来，我装的双系统，除了win11之外还有个测试用的ubuntu,这就好办了，更方便了，于是：</p><ul><li>F12 启动ubuntu</li><li>进入ubuntu以后，打开文件-其他位置，观察windows的C盘是哪个目录,或者在终端输入命令<code>sudo fdisk -l</code> \ <code>sudo blkid</code></li><li>使用mount命令挂载C盘</li><li>进入c:\window\system32,<code>mv osk.exe osk.exe.bak</code> \ <code>cp cmd.exe osk.exe</code>,备份osk,使用cmd替换osk,我这里是为了便于在登陆页面调用，替换的是虚拟键盘的程序，你也可以替换辅助访问程序。这里梳理下可以在登陆页面不需要管理员权限就能打开的应用：虚拟键盘osk.exe\辅助访问管理器utilman.exe\屏幕阅读器Magnify.exe\屏幕键盘TabTip.exe</li><li>进入windows系统，登陆页面，打开osk,快捷键win+u,选择虚拟键盘，这是cmd会打开。</li><li>输入<code>net user</code>查看用户名</li><li>使用 <code>net user &lt;usrname&gt; &lt;password&gt;</code> 修改新密码</li><li>使用新密码登陆即可。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常中我使用AI的主要场景</title>
      <link href="/2023/08/30/%E6%97%A5%E5%B8%B8%E4%B8%AD%E6%88%91%E4%BD%BF%E7%94%A8AI%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/08/30/%E6%97%A5%E5%B8%B8%E4%B8%AD%E6%88%91%E4%BD%BF%E7%94%A8AI%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>今年自 ChatGP 依赖，各种 AI 模型大盛行，各种 AI 工具也是层出不穷，其中不泛很多优秀的工具，这些工具大大提高了效率。这里就我个人的使用场景及体验做简单介绍：</p><h1 id="工具：-POE"><a href="#工具：-POE" class="headerlink" title="工具： POE"></a>工具： POE</h1><p>一个聚合 AI 工具，包括 ChatGpt 3.4 &#x2F; 4.0 \ Claude&#x2F;Claude 2.0 \ Midjourary \ Google-paLM 等。<br>上手快，使用方便。</p><h1 id="使用场景：-写代码"><a href="#使用场景：-写代码" class="headerlink" title="使用场景： 写代码"></a>使用场景： 写代码</h1><p>使用 AI 辅助写代码确实非常方便，但是一定要注意，会有错误，自己要能准确的描述需求，能及时指正最优解的思路。效率是真的高，还能解决你遇到的难题。</p><h1 id="工具：-沉浸式翻译"><a href="#工具：-沉浸式翻译" class="headerlink" title="工具： 沉浸式翻译"></a>工具： 沉浸式翻译</h1><p>这个工具手机和桌面都安装，主要功能是网页翻译，但是这不是它最强的，最强的是翻译本地文件。<br>前期是免费的，不过被收购以后，最近退出了付费订阅，也是值得的。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ventura 13.1 频繁提示 后台项目 已添加 解决方案</title>
      <link href="/2023/08/15/Ventura-13-1-%E9%A2%91%E7%B9%81%E6%8F%90%E7%A4%BA-%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE-%E5%B7%B2%E6%B7%BB%E5%8A%A0-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/08/15/Ventura-13-1-%E9%A2%91%E7%B9%81%E6%8F%90%E7%A4%BA-%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE-%E5%B7%B2%E6%B7%BB%E5%8A%A0-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Ventura 13.1 在使用过程中频繁提示“后台项目已添加”的通知，只是在尝试进行添加，并未添加成功，却频繁的提示，并不能彻底关闭。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>清空登录项数据</p><p>终端命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sfltool resetbtm</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在用观影软件推荐及广告屏蔽实现</title>
      <link href="/2023/07/15/%E5%9C%A8%E7%94%A8%E8%A7%82%E5%BD%B1%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%8F%8A%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/15/%E5%9C%A8%E7%94%A8%E8%A7%82%E5%BD%B1%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%8F%8A%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="在用的几个不错的观影软件"><a href="#在用的几个不错的观影软件" class="headerlink" title="在用的几个不错的观影软件"></a>在用的几个不错的观影软件</h2><pre><code>- NETFLIX- HDO BOX- Tea TV- ODC- TvBox</code></pre><h2 id="NETFLIX"><a href="#NETFLIX" class="headerlink" title="NETFLIX"></a>NETFLIX</h2><p>奈飞 就不用过多介绍了，自购账号或者自己组个车，是最佳的选择，也是最为推荐的。</p><p>支持 android\ios\macos\网页\TV 端。</p><p>需要解锁网络，对节点有要求。最近苹果调税了，不过还是推荐土区订阅再换区。</p><p>付费观看，无广告</p><h2 id="HDO-BOX"><a href="#HDO-BOX" class="headerlink" title="HDO BOX"></a>HDO BOX</h2><p>HDO BOX 一款聚合影视应用，聚合了 netflix \ apple tv \ prime video \ hulu \ disney+ \ HBO \ AMC \PParamounl+ 等内容的影视平台。</p><p>需要解锁网络，支持 andorid \ ios（自签\伪装上架）\ tv 端体验不佳</p><p>有广告，附去广告配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># &gt; hdo <span class="type">box</span> 去广告</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,applovin.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,applvn.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,doubleclick.net</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,vungle.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,adcolony.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,unity3d.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-KEYWORD,addthis.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-KEYWORD,vungle.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-KEYWORD,rayjump.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,analytics.dspunion.com</span><br><span class="line"><span class="keyword">DOMAIN</span>-SUFFIX,inappcheck.itunes.apple.com</span><br></pre></td></tr></table></figure><h2 id="Tea-TV"><a href="#Tea-TV" class="headerlink" title="Tea TV"></a>Tea TV</h2><p>类似 hdo box 的一款聚合应用。</p><p>需要解锁网络。支持 android \ ios \ tv \ windows</p><p>TV 端需要配合播放器使用，默认 TPlayer,有广告.附去广告规则：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># &gt; Tplayer播放器</span></span><br><span class="line">DOMAIN-<span class="function"><span class="keyword">KEYWORD</span>,<span class="title">unity3d</span></span></span><br><span class="line"><span class="function"><span class="title">DOMAIN</span>-<span class="title">KEYWORD</span>,<span class="title">applvn</span></span></span><br></pre></td></tr></table></figure><h2 id="ODC"><a href="#ODC" class="headerlink" title="ODC"></a>ODC</h2><p>ondemandchina 一款华人影视，质量非常棒，页面简洁、无广告，给人感觉很舒服。</p><p>目前锁区，需要北美 ip 访问，解锁网络时请注意。支持 andorid \ ios \ Tv \ 网页</p><p>无广告</p><h3 id="TvBox"><a href="#TvBox" class="headerlink" title="TvBox"></a>TvBox</h3><p>开源影视聚合软件，需要自定义软件源，目前衍生的版本有很多，体验感比较好的时小苹果（仿版比较多），国产影视聚合工具良心的不多，使用时自行甄选吧。</p><p>支持影视付费，只要有所值。毕竟：</p><blockquote><p>免费的都是产品，付费的才是用户。</p></blockquote><p>另外推荐几个目前还不错的影视相关站点：</p><p><a href="https://www.dubokuz.com/">独 播 库</a> &#x2F; <a href="https://awwrated.com/zh-tw/netflix">awwrated - 剧荒时逛逛</a> &#x2F; <a href="https://subhd.tv/">字 幕 下 载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 去广告 </tag>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载tikTok和抖音音频、视频的捷径</title>
      <link href="/2023/07/14/%E4%B8%8B%E8%BD%BDtikTok%E5%92%8C%E6%8A%96%E9%9F%B3%E9%9F%B3%E9%A2%91%E3%80%81%E8%A7%86%E9%A2%91%E7%9A%84%E6%8D%B7%E5%BE%84/"/>
      <url>/2023/07/14/%E4%B8%8B%E8%BD%BDtikTok%E5%92%8C%E6%8A%96%E9%9F%B3%E9%9F%B3%E9%A2%91%E3%80%81%E8%A7%86%E9%A2%91%E7%9A%84%E6%8D%B7%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/14/Obu1esBmRf7KnvE.png" alt="20230714104451.png"></p><p>一直在使用 <a href="../../../06/23/yt-dlp%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/">yt-dlp</a> 下载视频、提取音频，只是目前对抖音的配置还没完成，尝试了几次都没有成功，于是临时写了一个 ios 捷径，借用 saveTik.co 的 api 来实现下载视频和音频。<br>我的主要需求是提取一些翻唱和一些原创的音乐，所以是按照提取 mp3 来配置的，但同时也保留了 mp4 和 mp4 HD 下载的功能，只需要修改最后的提取参数为 2 或者 3 即可。</p><h2 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h2><p>· 复制视频分享链接，运行本捷径。</p><p>·另一种：直接在视频分享里调用 更多分享 ，选中本捷径即可。</p><p>运行本捷径以后，默认保持为 mp3 格式，文件名调整为了视频的文案。</p><p>下载的文件的保持路径默认为 &#x2F;spotify，我是为了 spotify 能直接读取，你可以根据实际需求自行修改保存路径。</p><h2 id="捷径下载抖音音频下载-fqw000"><a href="#捷径下载抖音音频下载-fqw000" class="headerlink" title="捷径下载抖音音频下载-fqw000"></a>捷径下载<a href="https://www.icloud.com/shortcuts/d11d07ed70224ad98d7f96d0e866317b">抖音音频下载-fqw000</a></h2><h2 id="附-yt-dlp-的捷径-yt-dlp-mp3"><a href="#附-yt-dlp-的捷径-yt-dlp-mp3" class="headerlink" title="附 yt-dlp 的捷径 yt-dlp.mp3"></a>附 yt-dlp 的捷径 <a href="https://t.me/neteasyios/72">yt-dlp.mp3</a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 下载 </tag>
            
            <tag> 捷径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Immersive Translate一个好用的翻译工具</title>
      <link href="/2023/07/01/Immersive-Translate%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/07/01/Immersive-Translate%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>AI 爆发以后，翻译工具层出不穷，优秀的翻译工具也有不少，有两个特别值得推荐的：</p><ul><li><a href="https://github.com/ripperhe/Bob">Bob</a>， 非 MAC 用户使用插件： <a href="https://github.com/openai-translator/openai-translator">openai-translator</a></li><li><a href="https://immersivetranslate.com/">Immersive Translate</a></li></ul><p>ios 版本可以选择 appsore 安装，也可通过扩展工具 Stay\injectscript 等安装，功能是一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storm Sniffer的功能解锁</title>
      <link href="/2023/06/26/Storm%20Sniffer%E7%9A%84%E5%8A%9F%E8%83%BD%E8%A7%A3%E9%94%81/"/>
      <url>/2023/06/26/Storm%20Sniffer%E7%9A%84%E5%8A%9F%E8%83%BD%E8%A7%A3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Storm-Sniffer-网络抓包工具的-vip-功能解锁"><a href="#Storm-Sniffer-网络抓包工具的-vip-功能解锁" class="headerlink" title="Storm Sniffer 网络抓包工具的 vip 功能解锁"></a>Storm Sniffer 网络抓包工具的 vip 功能解锁</h2><ul><li><p>脚本方案：<br>主要是使用一下两个插件来试下 vip 功能：<br><a href="https://raw.githubusercontent.com/fqw000/tools/main/plugin/stormsniffer1.plugin">stormsniffer1.plugin</a><br><a href="(https://raw.githubusercontent.com/fqw000/tools/main/plugin/stormsniffer2.plugin">stormsniffer2.plugin</a><br>这里是使用 Loon 配置的插件，使用时保持插件开启在打开 stormsniffer 即可实现 vip 功能解锁。</p></li><li><p>adbk 备份文件方案<br>主要是使用会员的到处的 adbk 备份文件，在需要破解的机器上恢复备份文件实现 vip 功能，可以参考<a href="../../09/%E4%B8%80%E7%A7%8Dios%E5%86%85%E8%B4%AD%E7%9A%84%E7%A0%B4%E8%A7%A3%E5%AE%9E%E7%8E%B0/">一种 ios 内购的破解实现</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> carck </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios抓包去广告的一个操作实例演示</title>
      <link href="/2023/06/26/ios%E6%8A%93%E5%8C%85%E5%8E%BB%E5%B9%BF%E5%91%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
      <url>/2023/06/26/ios%E6%8A%93%E5%8C%85%E5%8E%BB%E5%B9%BF%E5%91%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/06/26/gKtTNQzfWOAcldB.jpg" alt="photo_2023-06-26_10-47-29.jpg"></p><h3 id="555-影视的-ios-伪装上架-app-去广告"><a href="#555-影视的-ios-伪装上架-app-去广告" class="headerlink" title="555 影视的 ios 伪装上架 app 去广告"></a>555 影视的 ios 伪装上架 app 去广告</h3><p>AppStore 上很多影视 APP 都是伪装上架，555 影视是其中之一，除了一些色情系的广告植入之外其他都还是不错的，并且支持 TV 端。这里就使用纯 ios 端演示下如何去抓包并实现去广告</p><h3 id="主要工具"><a href="#主要工具" class="headerlink" title="主要工具"></a>主要工具</h3><p>抓包工具：Storm Sniffer(小螃蟹)。其他抓包工具也同理，appstore 上抓包工具非常多。<br>重写工具：LOON,类似的网络调试工具也很多，自行选择。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>开启 Storm Sniffer，打开 mitm 和 http capture</li><li>打开 555 影视，内容加载完成</li><li>关闭 http capture，打开抓取的数据，并找到疑似广告内容的数据请求，优先从图片请求中筛选更直观.</li><li>复制该 request url 的文件名，在所有请求中查找该文件名，打开筛选的请求及 response 并确认是否有含有广告内容</li><li>分析 json 数据，找出广告内容的规律：轮播广告的<code>type</code>值都是 <code>3</code>,banner 广告的 <code>layout</code>值都是<code>adbert_self</code></li><li>根据找出的规律写个 js，并将请求的 url 转换成正则。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Mitm]</span></span><br><span class="line"><span class="comment">hostname =a.weilai555.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[Script]</span></span><br><span class="line"><span class="comment">http-response ^https?:\/\/a\.weilai555\.com:1000\/api\/v1\/movie\/index_recommend\?pack=([\w\/\+\%]+)&amp;signature=([\w]+)$ script-path=https://raw.githubusercontent.com/fqw000/tools/main/script/555.js, requires-body=true, binary-body-mode=false, timeout=10, tag=555去广告</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body = <span class="symbol">$respo</span>nse.body;</span><br><span class="line"><span class="keyword">var</span> obj = JSON.parse(body);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏蔽layout值为advert_self的项</span></span><br><span class="line"><span class="keyword">if</span> (obj.data &amp;&amp; obj.data.<span class="built_in">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newData = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.data.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.data[i].layout !== <span class="string">&quot;advert_self&quot;</span>) &#123;</span><br><span class="line">      newData.<span class="built_in">push</span>(obj.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.data = newData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤轮播图中type为3的项</span></span><br><span class="line"><span class="keyword">if</span> (obj.data &amp;&amp; obj.data.<span class="built_in">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> carousel = obj.data.<span class="built_in">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.title === <span class="string">&#x27;轮播图&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (carousel &amp;&amp; carousel.list &amp;&amp; carousel.list.<span class="built_in">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    carousel.list = carousel.list.<span class="built_in">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.type !== <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">$do</span>ne(&#123;<span class="attr">body</span>: JSON.stringify(obj)&#125;);</span><br></pre></td></tr></table></figure><ul><li>配置 loon，实现 rewrite。这里图方便配置成了<a href="https://raw.githubusercontent.com/fqw000/tools/main/plugin/555.plugin">555 去广告插件</a>,其他网络调试工具的配置请自行调整。</li></ul><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 555.plugin</span></span><br><span class="line"></span><br><span class="line"># <span class="number">555</span>去广告</span><br><span class="line"><span class="meta">#!name=555去广告</span></span><br><span class="line"><span class="meta">#!desc=不包含开屏广告</span></span><br><span class="line"><span class="meta">#!author=wangqifei</span></span><br><span class="line"></span><br><span class="line">[Mitm]</span><br><span class="line">hostname =a.weilai555.com</span><br><span class="line"></span><br><span class="line">[Script]</span><br><span class="line">http-response ^https?:\/\/a\.weilai555\.com:<span class="number">1000</span>\/api\/v1\/movie\/index_recommend\?pack=([\w\/\+\%]+)&amp;signature=([\w]+)$ script-path=https:<span class="comment">//raw.githubusercontent.com/fqw000/tools/main/script/555.js, requires-body=true, binary-body-mode=false, timeout=10, tag=555去广告</span></span><br></pre></td></tr></table></figure><h2 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h2><p>大意了这个 555 影视会不定期的更换域名和 ip,抓个几个经常用的域名，使用正则做了匹配，修改了下脚本，脚本里已更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> 去广告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yt-dlp一个优秀的视频下载工具</title>
      <link href="/2023/06/23/yt-dlp%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/23/yt-dlp%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="yt-dlp"><a href="#yt-dlp" class="headerlink" title="yt-dlp"></a>yt-dlp</h2><p>yt-dlp 是一个基于 youtube-dl 的命令行工具，用于下载网络视频和音频。它是 youtube-dl 的扩展版本，提供了更多的功能和选项，并且一般会更快地更新以适应视频网站的更改。除了支持 YouTube，yt-dlp 还支持许多其他视频和音频网站，包括 bilibili、 Vimeo、Dailymotion、Facebook、SoundCloud 等等。项目地址：<a href="https://github.com/yt-dlp/yt-dlp">yt-dlp</a></p><h2 id="安装及使用参考"><a href="#安装及使用参考" class="headerlink" title="安装及使用参考"></a>安装及使用参考</h2><p>使用参考：<a href="https://www.rapidseedbox.com/blog/yt-dlp-complete-guide">YT-DLP: The Complete Guide (2023)</a></p><h2 id="ios-端使用"><a href="#ios-端使用" class="headerlink" title="ios 端使用"></a>ios 端使用</h2><p>yt-dlp 在 windows、macos、linux 的安装使用以上已经介绍的非常详细了。抽时间阅读下文档基本的功能用法就可以掌握了。<br>在 ai 孙燕姿刚出来那会，个人有个需求就是在手机上下载这些 ai 孙燕姿的翻唱，毕竟在 pc 上下载再导入到手机比较繁琐。于是尝试了下在 ios 安装 yt-dlp。</p><p>ios 端需要安装 ish 或者 a-shell 等工具然后安装 yt-dlp.这里推荐 a-shell ,配置更方便些。</p><p>1.appstore 安装 a-shell。</p><p>2.安装 SW-DLT。<a href="https://routinehub.co/download/38094/">Shortcuts</a></p><p>3.运行 SW-DLT.注意首次运行需要设置 delete all –&gt; true 删除所有的 depends，然后设置 delete all –&gt; false 再运行更新 depends。（需要注意 a-shell 软件源的连通性）</p><p>4.运行 SW-DLT 使用功能(至少一次，确保 depens 安装正确)，或者在 a-shell 里使用命令运行 dy-dlp。</p><p>5.下载后的文件在 files-on My iphone - a-Shell 里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为Mate30 Pro安装Google框架</title>
      <link href="/2023/06/20/Pro%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/06/20/Pro%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="华为-x2F-荣耀-HMS-系手机安装-GMS-及-googleplay"><a href="#华为-x2F-荣耀-HMS-系手机安装-GMS-及-googleplay" class="headerlink" title="华为&#x2F;荣耀 HMS 系手机安装 GMS 及 googleplay"></a>华为&#x2F;荣耀 HMS 系手机安装 GMS 及 googleplay</h2><h3 id="开动前准备工装"><a href="#开动前准备工装" class="headerlink" title="开动前准备工装"></a>开动前准备工装</h3><p>1.确保手机无谷歌残留。打开应用管理（显示系统程序），搜索 google，如有，卸载。（提示：部分需要在设备管理器里解除相应的激活后卸载，以免卸载异常。）</p><p>2.下载文件包，包括 google 系及谷歌服务助手恢复文件。（助手功能已残，这里仅使用其激活功能。）所有文件已上传阿里云,需要在华为应用商店才能彻底卸载。</p><ul><li><p><a href="https://github.com/fqw000/huawei/releases/download/Googleframe/A.zip">huawei.zip</a>: 下载备份文件，用于安装谷歌服务助手便于激活。</p></li><li><p>0.apk: MicroG-Huawei fix eloygomezTV 0.2.12.203315-dirty (com.google.android.gms version:203315025)</p></li><li><p>1.apk: google 服务框架 10 (com.google.android.gsf version:29)</p></li><li><p>2.apk: googleplay 服务 17.8.57 (com.google.android.gms version:17857037)</p></li><li><p>3.apk: googleplay 商店 19.5.13-all[0][pr]303545793 (com.android.vending version:81951300)</p></li><li><p>4.apk: google 帐户管理程序 4.4.4-1227136 (com.google.android.gsf.login version:19)</p></li><li><p>5.apk: googleplay 服务 20.24.14[120408-319035315] (com.google.android.gms version:202414033)</p><p>3.自备梯子。</p><p>4.关闭应用分身</p><p>5.关闭 google 账号的两部验证</p></li></ul><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="严格按照步骤操作"><a href="#严格按照步骤操作" class="headerlink" title="严格按照步骤操作"></a>严格按照步骤操作</h3><p>1.解压缩文件包。</p><p>使用自带文件管理工具解压，解压缩路径修改为 我的手机 ！！！！，解压后的文件夹内的 Huawei.zip 解压到默认路径，不要动！(一定要保证路径为：我的手机)<br>异常处理：解压路径不对会导致下一步操作找不到 从内部存储恢复 选项！！！，没有就退出再进。</p><p>2.使用备份恢复功能安装谷歌服务助手。<br>如果没有应用和恢复功能，记得到 华为应用商店 下载 备份 软件。</p><ul><li>调整系统时间为 2020 年 5 月（必要，否则出现异常！）</li><li>使用备份和恢复功能，点击右上角找到 从内部存储恢复 ，如果没有这个选项： 合适上一步文件解压路径是否完全正确！从新进入备份和恢复选项。</li><li>选择备份文件打开，勾选应用+数据。<br>异常处理：华为升级了备份软件，新版修正了部分功能，很多教程是告诉你 pc 端 adb 卸载掉 com.huawei.Backup，然后安装旧版本的备份软件，没有错，但是失效了，华为做了修正，安装旧版后系统会提示你版本低不能使用备份和恢复功能，可以使用 Hisuite 恢复备份，但是打开谷歌服务助手会出现 网络链接异常 的提示。主要是只恢复了应用，没有能恢复数据。</li><li>打开谷歌服务助手-激活，提示始终允许确认</li><li>恢复系统时间</li></ul><h3 id="从这里开始一下操作要全程挂梯子，包括过程中重启手机后。"><a href="#从这里开始一下操作要全程挂梯子，包括过程中重启手机后。" class="headerlink" title="从这里开始一下操作要全程挂梯子，包括过程中重启手机后。"></a>从这里开始一下操作要全程挂梯子，包括过程中重启手机后。</h3><p>3.开始安装。（也可以使用 googlefier 来安装）</p><ul><li>安装 0.apk: MicroG-Huawei fix eloygomezTV 0.2.12.203315-dirty<br>安装后打开登录 google 账号<br>异常处理：此处要把使用的账号都登录了，如果有多个账号的话。之后就不能再添加了！！<ul><li>依次安装 1.apk: google 服务框架 10 、3.apk: googleplay 商店 19.5.13-all[0][pr]303545793 、4.apk: google 帐户管理程序 4.4.4-1227136</li><li>卸载 MicroG</li><li>安装 2.apk: googleplay 服务 17.8.57</li><li>异常处理：安装后通知栏会不停的出现错误通知，不要管，安装后要等这个报错出现。</li><li>打开 play 商店，这里应该是已经可以运行了，然后关闭 play 商店后台</li><li>打开应用管理（显示系统程序），搜索 google：<br>*paly-强制停止<br>*谷歌账户管理程序-强制停止-删除数据<br>*谷歌服务框架-强制停止-清空缓存-删除数据<br>*重启手机</li><li>安装 2.apk: googleplay 服务 17.8.57,之后直接重启手机</li><li>打开 play 商店，确认运行后关闭后台</li><li>应用程序管理找到 play 服务-删除所有数据-确定-强行停止（如果没显示灰色，多点击几次，务必确认按钮变灰色）-卸载</li><li>安装 5.apk: googleplay 服务 20.24.14[120408-319035315]，重启手机</li><li>测试 play 商店是否正常运行，功能是否正常</li><li>如异常，回滚以上步骤后重来！！</li><li>卸载无关程序：谷歌账户管理、谷歌服务助手。</li></ul></li></ul><h1 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h1><p>googleplay 版本更新以后加强了对未注册设备的检测，所有导致频繁弹出 设备未认证 的提示，使用 google 的自定义 room 注册 GSF 也不能避免，最终的解决方案是：</p><ul><li>保持 googleplay 的版本，不要更新最新版。</li><li>googleplay 会自动更新，所以要关闭这个自动更新，经实际验证在 googleplay 设置里的各项设置均不能避免自动更新</li><li>在手机设置-应用管理-googleplay 服务&#x2F;googleplay 商店-禁用网络权限</li><li>禁用网络权限以后实际并不影响应用的下载和使用。</li></ul><p>更新：发现鸿蒙禁用网络以后，并不能真正的切断 gole play 商店的网络，需要禁用 play 商店的 存储 权限 ，才能杜绝 goog play 服务的更新,当需要使用 play 商店时在打开 存储 权限，特别主意 通知栏里是否提示有 google play 正在更新 ，如有及时点击通知里的取消，取消 google play 的更新。</p><p>再次更新：鸿蒙系统的权限管理开始让我我自我怀疑了，应用管理关掉网络权限和存储权限以后发现，google play 商店的网络和下载都是正常的！权限基本无管理啊！最终的方案是，使用 V2rayNG 的分应用代理控制 google Play 商店的网络权限才得以以实现，但是家里的路由带外网权限就不方便了。于是把 google play 的后天权限改为手动，并打开消息通知，有应用跟新是就是的通知，如果是 google play 的更新就即使点击取消。</p><p>就是一个屏蔽升级的需求，实现起来也是曲线的很。</p><p>当然，也可以使用 Gbox。</p>]]></content>
      
      
      
        <tags>
            
            <tag> huawei </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt定时更新host文件的方案</title>
      <link href="/2023/06/14/openwrt%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0host%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%A1%88/"/>
      <url>/2023/06/14/openwrt%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0host%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>openwrt 安装以后一直没办法解决 github DNS 污染的问题，raw 和 github 图片都不能访问，导致大量的文件不能更新，或者只能访问凭运气。于是就需要配置 github 的 host 来解决 DNS 污染，写了个脚本来实现。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>备份现有 host 文件到 hosts_origin(注意如无则新建，如有则覆盖)，并调整本分文件权限</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>hosts <span class="regexp">/etc/</span>hosts_origin</span><br><span class="line">chmod <span class="number">664</span> <span class="regexp">/etc/</span>hosts_origin</span><br></pre></td></tr></table></figure><ul><li>在 root 目录下新建 hostsUpdate.sh 文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line">wget -q https:<span class="regexp">//</span>hosts.gitcdn.top<span class="regexp">/hosts.txt -O /</span>tmp/hostsNew.txt --no-check-certificate</span><br><span class="line">cat <span class="regexp">/tmp/</span>hostsNew.txt <span class="regexp">/etc/</span>hosts_origin &gt; <span class="regexp">/tmp/</span>hostsNewAll.txt</span><br><span class="line">cp <span class="regexp">/tmp/</span>hostsNewAll.txt <span class="regexp">/etc/</span>hosts</span><br><span class="line">chmod <span class="number">664</span> <span class="regexp">/etc/</span>hosts</span><br><span class="line"><span class="regexp">/etc/i</span>nit.d/dnsmasq restart</span><br></pre></td></tr></table></figure><ul><li>修改 hostsUpdate.sh 文件权限</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">777</span> hostsUpdate.sh</span><br></pre></td></tr></table></figure><ul><li>执行 hostsUpdate.sh 文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/root/</span>hostsUpdate.sh</span><br></pre></td></tr></table></figure><ul><li>设置定时任务<br>在 openwrt 中添加定时任务，保存定时任务后在系统启动项中重启 cron。<br>每天 3 点定时更新</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">3</span> * * * /root/update_hosts.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快柠檬的节点提取和转换</title>
      <link href="/2023/06/09/%E5%BF%AB%E6%9F%A0%E6%AA%AC%E7%9A%84%E8%8A%82%E7%82%B9%E6%8F%90%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/06/09/%E5%BF%AB%E6%9F%A0%E6%AA%AC%E7%9A%84%E8%8A%82%E7%82%B9%E6%8F%90%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>测试 lemon 使用，过度依赖现有运行规则，随时会失效，不保证维护。<br>这里只是探索功能实现的技术记录，谢绝传播使用。</p></blockquote><p>鉴于 Clash 的完善，目前对各平台的良好支持，一个配置全平台通用的便利让我不的不考虑全面转战 Clash。<br>对个人而言：折腾 &gt; 使用 。</p><blockquote><p><a href="https://github.com/fqw000/lemon">项目地址</a></p></blockquote><h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><ul><li>通过提取快柠檬客户端 v2rayNG 的订阅链接通过 shortcuts 自动更新到 lemon.site</li><li><a href="https://raw.githubusercontent.com/fqw000/lemon/main/.github/workflows/extract_lemon_list.yml">extract-lemon-list.yml</a> 中没有加入异常处理机制，为确保运行正常，务必确保 lemon.site 文件内容为单行网址且仅有单行，<del>shortcuts 里有处理自动提交时可忽略该问题</del>（目前在写 shortcuts 的过程中遇到了不能正常使用 github api 异常还没解决）。</li><li>触发 GithubAction <a href="https://raw.githubusercontent.com/fqw000/lemon/main/.github/workflows/extract_lemon_list.yml">extract-lemon-list.yml</a><ul><li>每 3 个小时自动更新一次</li><li>读取 lemon.site 内的订阅链接网址对应的内容</li><li>将网址内容同步至 lemon.sub，解决 v2ray 订阅</li><li>对 lemon.sub 进行解码同步至 lemon.list，解决 loon 订阅</li><li>修改 lemon.site 读取的链接网址为客户端提供的 Clash 的订阅网址，并读取 clash 订阅到 lemon.yaml</li><li>提取 clash 订阅内的 proxies 内容到 lemonnode.yaml</li><li>使用 lemonlite.yaml 保存 clash 订阅内的 proxies 内容，并与 lemonbanner.yaml 合并到 lemonliste.yaml 形成一个完整的自定义订阅内容</li><li>注：lemonbanner.yaml 内容为代理集和规则集合。</li></ul></li><li>不是最优解，只是能用。</li><li>附 <a href="https://raw.githubusercontent.com/fqw000/lemon/main/.github/workflows/extract_lemon_list.yml">extract-lemon-list.yml</a> 参考</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">name: extract_lemon_list</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: <span class="string">&#x27;0 */3 * * *&#x27;</span></span><br><span class="line">  push:</span><br><span class="line">    branches: [ main ]</span><br><span class="line">    path:</span><br><span class="line">      - <span class="string">&quot;lemon.site&quot;</span></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  read-and-save:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout code</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">    - name: Read and save content</span><br><span class="line">      run: |</span><br><span class="line">          url=$(<span class="built_in">cat</span> lemon.site)</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;url=<span class="variable">$url</span>&quot;</span> &gt;&gt; <span class="variable">$GITHUB_ENV</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; lemon.sub</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; lemon.list</span><br><span class="line">          curl -L <span class="string">&quot;<span class="variable">$url</span>&quot;</span> -o lemon.sub</span><br><span class="line">          <span class="built_in">cat</span> lemon.sub | <span class="built_in">base64</span> -d &gt; lemon.list</span><br><span class="line"></span><br><span class="line">          url2=$(<span class="built_in">cat</span> lemon.site | sed <span class="string">&#x27;s/vrn/ch/g&#x27;</span>)</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;url2=<span class="variable">$url2</span>&quot;</span> &gt;&gt; <span class="variable">$GITHUB_ENV</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; lemon.yaml</span><br><span class="line">          curl -L <span class="string">&quot;<span class="variable">$url2</span>&quot;</span> -o lemon.yaml</span><br><span class="line"></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; lemonlite.yaml</span><br><span class="line">          <span class="built_in">cat</span> lemon.yaml | perl -ne <span class="string">&#x27;print unless /^proxy-group/../^$/&#x27;</span> &gt; lemonlite.yaml</span><br><span class="line">          <span class="built_in">cat</span> lemonlitebanner.yaml &gt;&gt; lemonlite.yaml</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; lemonnode.yaml</span><br><span class="line">          <span class="built_in">cat</span> lemon.yaml | perl -ne <span class="string">&#x27;print unless /^proxy-group/../^$/&#x27;</span> &gt; lemonnode.yaml</span><br><span class="line"></span><br><span class="line">    - name: Commit changes</span><br><span class="line">      run: |</span><br><span class="line">        git config --<span class="built_in">local</span> user.email <span class="string">&quot; &quot;</span></span><br><span class="line">        git config --<span class="built_in">local</span> user.name <span class="string">&quot; &quot;</span></span><br><span class="line">        git add lemon.sub lemon.list lemon.yaml lemonlite.yaml lemonnode.yaml</span><br><span class="line">        git commit -m <span class="string">&quot;Add lemon.sub lemon.list lemon.yaml lemonlite.yaml lemonnode.yaml&quot;</span></span><br><span class="line">        git push</span><br></pre></td></tr></table></figure><h2 id="关于-github-action-的坑，萌新关注。"><a href="#关于-github-action-的坑，萌新关注。" class="headerlink" title="关于 github action 的坑，萌新关注。"></a>关于 github action 的坑，萌新关注。</h2><ul><li>涉及到文件提交等操作，需要在 repo 设置里代开 action 的读写权限,否则会面临提价失败。即使你是 owner</li><li><blockquote><p>setting-Actions-General-workflow permissions-打开 read and write permissions</p></blockquote></li></ul><h2 id="lemonlite-yaml"><a href="#lemonlite-yaml" class="headerlink" title="lemonlite.yaml"></a><del>lemonlite.yaml</del></h2><p><del>这里使用的是黑名单机制，gfw 列表走代理，其余 DIRECT,只是对 spotify 和 telegram 单独分流。<br>没有涉及任何去广告和 script 操作，去广告交给了 AdgurandHome 和 adbyby.</del></p><h2 id="lemon-usr-yaml"><a href="#lemon-usr-yaml" class="headerlink" title="lemon-usr.yaml"></a><a href="https://raw.githubusercontent.com/fqw000/lemon/main/lemon-usr.yaml">lemon-usr.yaml</a></h2><p>舍弃了<del>lemonlite.yaml</del>.使用了代理集和规则集的引用，只是使用了 <a href="https://raw.githubusercontent.com/fqw000/lemon/main/.github/workflows/extract_lemon_list.yml">extract-lemon-list.yml</a> 生成的 lemonnode.yaml 代理集文件。舍弃了没有代理集时的其他繁琐的实现操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联系人信息跨设备即时同步的实现方案</title>
      <link href="/2023/06/09/%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF%E8%B7%A8%E8%AE%BE%E5%A4%87%E5%8D%B3%E6%97%B6%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
      <url>/2023/06/09/%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF%E8%B7%A8%E8%AE%BE%E5%A4%87%E5%8D%B3%E6%97%B6%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/06/09/Zy84RqI1k2a7tsE.png" alt="image.png"></p><blockquote><p>需求：各终端数据即时同步，换设备使用时不用来回导通讯录</p></blockquote><h2 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a><strong>实现方案：</strong></h2><p><strong>DAVx⁵+iCloud</strong></p><p><a href="https://www.davx5.com/">CalDAV, CardDAV and WebDAV for Android — DAVx⁵</a></p><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果：</strong></h2><p>Android、ios、Mac 端保持联系人随时同步（新增和删除均可），不限设备数量，项目开源。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h2><p>这里需要在 icloud 里生成专用密码授权登录，不是使用 icloud 的登录密码！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> anroid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种ios内购的破解实现</title>
      <link href="/2023/06/09/%E4%B8%80%E7%A7%8Dios%E5%86%85%E8%B4%AD%E7%9A%84%E7%A0%B4%E8%A7%A3%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/09/%E4%B8%80%E7%A7%8Dios%E5%86%85%E8%B4%AD%E7%9A%84%E7%A0%B4%E8%A7%A3%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/06/09/ES1mkFLO6RrQpZf.png" alt="image.png"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>通过将内购信息 adbk 备份文件导入非解锁内购的个人 Apple ID 下载的本应用内，实现内购信息与个人 Apple ID 的绑定，再通过应用数据的备份与还原功能实现在不能使用 Apps Manger 的 ios 设备上还原备份信息，实现内购的破解。</p><h2 id="步骤描述"><a href="#步骤描述" class="headerlink" title="步骤描述"></a>步骤描述</h2><ul><li>使用 Apps Manger 将已经内购的应用的内购信息备份成 adbk 文件。你也可以从网络等其他途径获得应用的 adbk 文件。</li><li>使用个人 Apple ID 下载该应用。</li><li>使用 Apps Manger 将含有内购信息的 adbk 文件还原到下载的应用。</li><li>使用 iMazing 将该应用数据备份导出。</li><li>使用 iMazing 在没有 Apps Manger 的任意版本号的设备（即使是 15.4.1 以上的系统也 OK）上将导出的应用宝数据备份还原。</li></ul><p>❗️ 对于需要绑定设备 ID 或者 icloud 的应用不要有太大的期待。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果您不确定如何操作，建议先了解相关知识并备份好数据，以免出现意外情况。同时，<strong>这里只验证可行性</strong>，也要注意不要滥用内购恢复功能，尊重开发者的劳动成果并支持正版软件。👍</p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米电视调用原声安卓设置</title>
      <link href="/2023/06/08/%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86%E8%B0%83%E7%94%A8%E5%8E%9F%E5%A3%B0%E5%AE%89%E5%8D%93%E8%AE%BE%E7%BD%AE/"/>
      <url>/2023/06/08/%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86%E8%B0%83%E7%94%A8%E5%8E%9F%E5%A3%B0%E5%AE%89%E5%8D%93%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>占个坑，慢慢补</p></blockquote><p>前期的版本内还有隐藏的原生 setting，目前的版本均已经阉割彻底。只是，安装对应版本的原生 setting 即可直接调用，务必注意版本要对应，否则会出现无法打开。</p><h2 id="为什么需要原生-setting"><a href="#为什么需要原生-setting" class="headerlink" title="为什么需要原生 setting"></a>为什么需要原生 setting</h2><p>当然是为了完善的设置选项，比如网络配置的自定义等，根据个人需求选择。</p><h2 id="去哪里找原生-setting"><a href="#去哪里找原生-setting" class="headerlink" title="去哪里找原生 setting"></a>去哪里找原生 setting</h2><p>appmirror ,注意安卓版本号需要对应。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电视盒子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiTV更换Launcher</title>
      <link href="/2023/06/08/MiTV%E6%9B%B4%E6%8D%A2Launcher/"/>
      <url>/2023/06/08/MiTV%E6%9B%B4%E6%8D%A2Launcher/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需求：纯净的电视操作和观影体验。</p></blockquote><h2 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a><strong>实现方案：</strong></h2><p>ADB+bat 脚本+lenbacklauncher+emotn</p><p><a href="https://developer.android.com/tools/adb">Android Debug Bridge (adb)  |  Android Studio  |  Android Developers</a></p><p><a href="https://github.com/tsynik/LeanbackLauncher/releases">Releases · tsynik&#x2F;LeanbackLauncher</a></p><p><a href="https://github.com/fqw000/tv/blob/main/%E5%B0%8F%E7%B1%B3%E7%94%B5%E8%A7%86%E7%B2%BE%E7%AE%80.bat">tv&#x2F;小米电视精简.bat at main · fqw000&#x2F;tv</a></p><p><a href="https://app.emotn.com/"></a></p><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果</strong>：</h2><p>原生 AndroidTV 桌面替换小米桌面并删除各种 mi 服务，启动速度快、无广告，可安装网络工具、netflix、smartTube、HdoBOX、TVBox、秒看直播、BBLL（B 站客户端）、AdguradPro（没有去广告的网络环境可以安装）等。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>开启小米电视（盒子）开发者模式。</li><li>打开开启 ADB。</li><li><strong>安装第三方 Launcher 软件</strong> 删除自带 launcher 前务必确保第三方 Launcher 以安装并测试能正常运行。</li><li>建立 adb 连接，可以使用双母口 USB(没有的可以自己使用两条 usb 线改造下)，Win 端执行一键脚本，根据提示配置即可。</li><li>也可是使用 adb wifi 连接工具比如<strong>甲壳虫 adb</strong>，adb 连接以后逐条执行 bat 内的命令。</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h2><p>此 bat 文件操作会删除小米原有大部分服务，慎重原则，恢复需要重置电视。如不想更改原有系统，可选择使用按键映射软件将 home 键映射到对应的 launcher 即可。</p><h2 id="附上根据个人需求写的一键脚本-bat-文件"><a href="#附上根据个人需求写的一键脚本-bat-文件" class="headerlink" title="附上根据个人需求写的一键脚本 bat 文件"></a>附上根据个人需求写的一键脚本 bat 文件</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">chcp <span class="number">936</span></span><br><span class="line">:: 修改文字颜色</span><br><span class="line">color a</span><br><span class="line"></span><br><span class="line">:: title</span><br><span class="line">title 小米电视<span class="number">1.3</span>.<span class="number">85</span>(稳定版）精简</span><br><span class="line">echo 小米电视<span class="number">1.3</span>.<span class="number">85</span>(稳定版）精简</span><br><span class="line">echo <span class="number">2021</span>-<span class="number">11</span>-<span class="number">13</span></span><br><span class="line">echo by 王奇飞</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">::adb 版本</span><br><span class="line">echo adb版本号：</span><br><span class="line">adb <span class="keyword">version</span></span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">echo <span class="comment">###开始设备连接##。</span></span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">::连接电视（更换为自己的地址）请输入</span><br><span class="line">set /p <span class="attr">ipinput=</span>请输入目标电视ip地址:</span><br><span class="line">echo.</span><br><span class="line">echo 输入的ip地址为: %ipinput%</span><br><span class="line">echo.</span><br><span class="line">set /p <span class="attr">portinput=</span>请输入目标电视adbd监听端口:</span><br><span class="line">echo.</span><br><span class="line">echo 输入的监听端口为: %portinput%</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">::adb connect %ipinput%:%portinput% &gt;linkreturn.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::findstr <span class="string">&quot;cannot&quot;</span> linkreturn.txt &gt;nul &amp;&amp;(goto end)||(goto <span class="literal">start</span>)</span><br><span class="line"></span><br><span class="line">:<span class="literal">start</span></span><br><span class="line">adb connect %inimput%:%portinput%</span><br><span class="line">::echo 确认连接设备信息：</span><br><span class="line">adb devices</span><br><span class="line">::pause</span><br><span class="line">echo 开始精简系统</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.mipay.wallet.tv</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.mitv.alarmcenter</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.mitv.gallery</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.mitv.screensaver</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.miui.systemAdSolution</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.miui.tv.analytics</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.sogou.speech.offlineservice</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.devicereport</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mibox.gamecenter</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mibox.lockscreen</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.miplay</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.appstore</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.handbook</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.karaoke.service</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.pay</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.tvpush.tvpushservice</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.screenrecorder</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.smarthome.tv</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.voicecontrol</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.android.captiveportallogin</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.android.providers.downloads</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.gamecenter.sdk.service.mibox</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mimusic2</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.payment</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.shop</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.mitv.upgrade</span><br><span class="line">adb shEll pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.statistic</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.tv.appupgrade</span><br><span class="line">adb shell pm uninstall --<span class="keyword">user</span> <span class="title">0</span> com.xiaomi.tv.gallery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo 精简完成任意键退出</span><br><span class="line">pause</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">:::end</span><br><span class="line">::<span class="keyword">type</span> linkreturn.txt</span><br><span class="line">::echo 连接故障。任意键退出</span><br><span class="line">::pause</span><br><span class="line">::rem exit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 电视盒子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一个MicrosoftStore抓包下载的在线工具</title>
      <link href="/2023/06/08/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AAMicrosoftStore%E6%8A%93%E5%8C%85%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/08/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AAMicrosoftStore%E6%8A%93%E5%8C%85%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Online-link-generator-for-Microsoft-Store"><a href="#Online-link-generator-for-Microsoft-Store" class="headerlink" title="Online link generator for Microsoft Store"></a>Online link generator for Microsoft Store</h2><p>因为串口调试工具只在 MicrosoftStore 提供，好巧不巧我安装的 tiny win10 没有，于是翻到了这个在线工具：</p><p><a href="https://store.rg-adguard.net/">抓包 MicrosoftStore</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>360T7刷OpenWrt</title>
      <link href="/2023/06/08/360T7%E5%88%B7OpenWrt/"/>
      <url>/2023/06/08/360T7%E5%88%B7OpenWrt/</url>
      
        <content type="html"><![CDATA[<p>使用 360T7 刷入 openwrt 系统，主要借助 openclash、adguradhome 实现 <del>科 学 上 网</del>和 DNS 去广告。手搓了一份 clsh 的配置文件，但是配置中发现 openclash 不支持 reality，改用了 passwall。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h2><table><thead><tr><th>360T7</th><th></th></tr></thead><tbody><tr><td>windows 电脑</td><td>本操作均是基于 window 端</td></tr><tr><td>usb 转 ttl 工具</td><td>CH340 即可，电商网站很多</td></tr><tr><td>杜邦线+网线</td><td></td></tr><tr><td>uboot</td><td><a href="https://github.com/fqw000/360T7/releases/download/openwrt/mt7981_360t7-fip-fixed-parts-uboot.bin">108m 的 uboot</a> \ <a href="https://cmi.hanwckf.top/p/360t7-firmware/">来源</a></td></tr><tr><td>openwrt 固件</td><td><a href="https://github.com/fqw000/360T7/releases/download/openwrt/360t7.chajian-openwrt.zip">固件下载</a> \ <a href="https://www.right.com.cn/forum/thread-8263340-1-1.html">来源</a></td></tr><tr><td>串口调试助手</td><td>MicrosoftStore \ <a href="https://github.com/fqw000/360T7/releases/download/openwrt/chuankoutiaoshiyilai-Microsoft.NET.Native.Runtime.2.2_2.2.28604.0_x86__.appx">依赖</a> 、 <a href="https://github.com/fqw000/360T7/releases/download/openwrt/chuankoutiaoshiyilai-Microsoft.NET.Native.Runtime.2.2_2.2.28604.0_x86__.appx">依赖</a> 、 <a href="https://github.com/fqw000/360T7/releases/download/openwrt/chuankoutiaoshizhushou-lingguang.8.0.1.0.msixbundle">串口调试助手</a></td></tr><tr><td>termius</td><td>telnet 工具都可以</td></tr></tbody></table><p><em>部分没有 microsoftstore 的版本比如企业版，使用抓包的.appx 和.msixbundle 安装串口调试助手</em> <a href="../%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AAMicrosoftStore%E6%8A%93%E5%8C%85%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">推荐一个 MicrosoftStore 抓包下载的在线工具</a></p><h2 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a><strong>拆机</strong></h2><p>网上流传很多拆机教程，图文的、视频的都有自行参考吧<br> 以下是拆机的关键点：</p><ul><li>贴纸覆盖下的两颗十字螺丝拆解。想保护贴纸的就用风枪或者吹风机吹下把贴纸私下里。</li><li>准备一张废弃的塑料卡片（比如：过期的信用卡、会员卡），从底部中央插入，想一侧滑动，碰到卡口向上撬卡，使上盖向外，下盖向里滑动，依次撬开四个角和两侧的卡口，正上方的两个卡口不好撬，其实不用撬，以顶为轴心从底部上掀上盖，正上方两卡口即可脱落</li><li>绞和方式为底盖卡牙靠外侧向内扣紧上盖卡扣，上盖卡扣靠内测。</li><li>基本都能无损不断扣拆解</li></ul><h2 id="failsafe-模式下开启-telnet"><a href="#failsafe-模式下开启-telnet" class="headerlink" title="failsafe 模式下开启 telnet"></a><strong>failsafe 模式下开启 telnet</strong></h2><ul><li>使用 usb 转 ttl 工具+杜邦线接线：路由 RXD 连接 ttl 工具的 TXD、TXD 连接 RXD、GND 连接 GND.底座朝下，主板由下方三个节点自下而上依次为 RXD、TXD、GND。<br>注意观察路由主板，三个圆孔一个方孔，三个圆孔没有走线的孔（与方孔相临）为 GND,紧挨着 GND 有走线的一个圆孔为 TXD,另外一个圆孔则是 RXD。</li><li>打开串口调试助手,串口号选择插入 COM 口设备，波特率选择到 115200，然后选择连接。</li><li>路由器接通电源，调试助手右侧开始日志开始显示，不停的输入 f+回车 发送，直至显示进入 failsafe 模式。</li><li>依次执行以下命令<br>&amp;darr; 开启 uboot 控制台菜单<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fw_setenv</span> bootmenu_delay <span class="number">3</span></span><br></pre></td></tr></table></figure>&amp;darr;挂载 rootfs 并开启 telnet<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount_root</span><br><span class="line">sed -i <span class="string">&#x27;s/.*local debug=.*/\tlocal debug=1/&#x27;</span> <span class="regexp">/etc/i</span>nit.d/telnet</span><br></pre></td></tr></table></figure>&amp;darr;修改 root 密码为 password<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br><span class="line"><span class="keyword">password</span></span><br><span class="line"><span class="keyword">password</span></span><br></pre></td></tr></table></figure>&amp;darr;重启<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="刷入-uboot"><a href="#刷入-uboot" class="headerlink" title="刷入 uboot"></a><strong>刷入 uboot</strong></h2><ul><li>路由重启后，进入并配置路由，确保路由能够联网（如果需要从网络下载 uboot 文件，你也可以将 uboot 文件使用 HSF、SCP 等方式直接上传到路由使用），原厂的 uboot 只能使用 36M，hanwckf 的可以使用 108M。</li><li>使用 termius 对路由器进行 telnet 连接，默认的后台地址是 192.168.2.1，用户名是 root，密码是 password（这就是上一步修改的密码）</li><li>将 uboot 写入 &#x2F;tmp&#x2F; 路径，将 360t7-fip-fixed-parts.bin 文件中的数据写入到 Linux 内核中名为 fip 的 MTD 设备分区中。当然你也可以使用 mtd 命令写入刚下载好的 uboot。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /tmp</span><br><span class="line">wget https://sebs.oss-<span class="keyword">cn</span>-shanghai.aliyuncs.<span class="keyword">com</span>/<span class="number">360</span>t7-fip-fixed-parts.bin</span><br><span class="line">mtd <span class="keyword">write</span> <span class="number">360</span>t7-fip-fixed-parts.bin fip</span><br></pre></td></tr></table></figure><h2 id="刷入-openwrt"><a href="#刷入-openwrt" class="headerlink" title="刷入 openwrt"></a><strong>刷入 openwrt</strong></h2><ul><li>进入 uboot<br>摁住路由 reset 按键，通电，持续 8 秒以上松开即可进入 reboot</li><li>uboot 没有 DHCP，所有需要使用网线将路由的 lan 口和电脑连接。<br>电脑端：<br>IP 手动设置为 192.168.1.2<br>子网掩码 255.255.255.0<br>网关设置 192.168.1.1<br>dns 也设置 192.168.1.1</li><li>浏览器打开 192.168.1.1 进入 uboot 管理页面，选择下载好的 openwrt 固件，注意文件格式需要为.bin 不能使压缩包</li><li>刷入完成后，自动重启进入 openwrt<br>默认后台是 192.168.6.1，用户名是 root，密码 password，默认的 Wi-Fi 名是 mtk 开头的，默认 Wi-Fi 没有密码</li></ul><h2 id="最后附上-360t7-的-原生固件备份"><a href="#最后附上-360t7-的-原生固件备份" class="headerlink" title="最后附上 360t7 的  原生固件备份 "></a>最后附上 360t7 的 <a href="https://github.com/fqw000/360T7/releases/download/openwrt/360T7-yuanshengrom-bak.7z"> 原生固件备份 </a></h2><h3 id="原厂固件分区表"><a href="#原厂固件分区表" class="headerlink" title="原厂固件分区表"></a>原厂固件分区表</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0x000000000000</span>-<span class="number">0</span>x000000100000 : <span class="string">&quot;bl2&quot;</span></span><br><span class="line"><span class="attribute">0x000000100000</span>-<span class="number">0</span>x000000180000 : <span class="string">&quot;u-boot-env&quot;</span></span><br><span class="line"><span class="attribute">0x000000180000</span>-<span class="number">0</span>x000000380000 : <span class="string">&quot;Factory&quot;</span></span><br><span class="line"><span class="attribute">0x000000380000</span>-<span class="number">0</span>x000000580000 : <span class="string">&quot;fip&quot;</span></span><br><span class="line"><span class="attribute">0x000000580000</span>-<span class="number">0</span>x000002980000 : <span class="string">&quot;ubi&quot;</span></span><br><span class="line"><span class="attribute">0x000002980000</span>-<span class="number">0</span>x000004d80000 : <span class="string">&quot;firmware-1&quot;</span></span><br><span class="line"><span class="attribute">0x000004d80000</span>-<span class="number">0</span>x000007180000 : <span class="string">&quot;plugin&quot;</span></span><br><span class="line"><span class="attribute">0x000007180000</span>-<span class="number">0</span>x000007280000 : <span class="string">&quot;config&quot;</span></span><br><span class="line"><span class="attribute">0x000007280000</span>-<span class="number">0</span>x000007300000 : <span class="string">&quot;factory&quot;</span></span><br><span class="line"><span class="attribute">0x000007300000</span>-<span class="number">0</span>x000007a00000 : <span class="string">&quot;log&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中，Factory 为无线 EEPROM 分区；fip 为 uboot 分区；ubi 和 firmware-1 为固件分区，分别 36M，均为 ubi 格式；plugin 为原厂插件分区，有 36M，也是 ubi 格式；最后一个小写字母开头的 factory 分区为原厂固件信息分区，保存有机器编号，MAC 地址等信息。<br>原厂 uboot 在开机时会分别检查 ubi 和 firmware-1 分区内是否存在固件，如果某个分区未检查通过，则 uboot 会自动将另一个分区的内容复制过去。<br>因此，当使用原厂 uboot 启动时，只能使用一个 ubi 分区存放固件，固件总体积（含 kernel+rootfs+rootfs_data）将限制在 36M 内，但你仍然可以使用 plugin 分区（36M）存放其它数据<br> <a href="https://cmi.hanwckf.top/p/360t7-telnet-uboot-console/"> &gt;&gt;&gt;&gt;来源 </a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows系统安装推荐</title>
      <link href="/2023/06/08/windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%8E%A8%E8%8D%90/"/>
      <url>/2023/06/08/windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Tiny-win11-x2F-Tiny-win10-–NTDEV"><a href="#Tiny-win11-x2F-Tiny-win10-–NTDEV" class="headerlink" title="Tiny win11 &#x2F; Tiny win10 –NTDEV"></a>Tiny win11 &#x2F; Tiny win10 –NTDEV</h2><p>前段时间……</p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不使用MicrosoftStore安装Winget</title>
      <link href="/2023/06/08/%E4%B8%8D%E4%BD%BF%E7%94%A8MicrosoftStore%E5%AE%89%E8%A3%85Winget/"/>
      <url>/2023/06/08/%E4%B8%8D%E4%BD%BF%E7%94%A8MicrosoftStore%E5%AE%89%E8%A3%85Winget/</url>
      
        <content type="html"><![CDATA[<h2 id="winget"><a href="#winget" class="headerlink" title="winget"></a>winget</h2><p>winget 是优秀的 windows 端的软件管理工具，可以通过 MicrosoftStore 很便捷的安装，只是我在安装 win 的时候使用 Tiny10 安装了个 Windows 10 IoT 企业版 LTSC,没有 MicrosoftStore。以下是解决方案：<br>运行 powershell 执行以下命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-PSRepository -<span class="type">Name</span> <span class="string">&#x27;PSGallery&#x27;</span> -InstallationPolicy <span class="keyword">Trusted</span></span><br><span class="line">Install-Script -<span class="type">Name</span> winget-install -Force</span><br><span class="line">winget-install.ps1</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果你的 powershell 运行提示：because running scripts is disabled on this system’需要先解决这个报错。<br>报错原因是：powershell 中默认的 execution policy 是 restricted。可以使用 Get-ExecutionPolicy 查看其状态。<br>解决方案：设置 execution policy 为 remotesigned<br>PowerShell 执行以下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpotifyPremium实现</title>
      <link href="/2023/06/06/SpotifyPremium%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/06/SpotifyPremium%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="主要实现以下功能："><a href="#主要实现以下功能：" class="headerlink" title="主要实现以下功能："></a>主要实现以下功能：</h2><ol><li>去广告</li><li>去除 14 天检测</li><li><a href="/Spotify%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91%E5%AE%9E%E7%8E%B0.md">歌词翻译</a>（新版本虽已经引入，但效果欠佳）</li></ol><h2 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a><strong>实现方案：</strong></h2><p><strong>A:Spotify Premium</strong></p><p>B:Sprotify 脚本</p><p>Surge&#x2F;Loon&#x2F;Quantumult X&#x2F;ShadowRocketS 等网络调试工具+脚本文件+百度翻译 api</p><p><a href="https://apps.apple.com/us/app/loon/id1373567447">Loon</a> | <a href="https://github.com/fqw000/tools/blob/main/script/spotifypremium.js">spotifypremium 脚本</a> | <a href="https://github.com/fqw000/tools/blob/main/script/spotifylyric.js">spotifylyric 脚本</a></p><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果</strong>：</h2><ul><li><p>无广告、可保持更新、自由切歌、不用再考虑境外支付问题。</p></li><li><p>我是账号归属和日常使用网络环境均为同区，但 Spotify 的所有流量走的都是国内直连，几乎没出现过 14 天的问题。</p></li><li><p>非中文歌词均可逐行翻译成中文。</p></li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Spotify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spotify歌词翻译实现</title>
      <link href="/2023/06/06/Spotify%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/06/Spotify%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><ul><li>·<strong>注册百度翻译个人开发者，然后申请百度翻译的 appid 和 key。接下来要在脚本文件里使用</strong>。<br>建议申请高级版，标准版可能不够用。</li><li><strong>使用网络工具配置 mitm 域名：</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hostname</span> <span class="string">=spclient.wg.spotify.com</span></span><br></pre></td></tr></table></figure></li><li>使用网络工具配置脚本文件（注意将其中的 appid 和 securityKey 替换为自己的），不同软件配置不同参考以下内容：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http-response</span> <span class="string">^https:\/\/spclient\.wg\.spotify\.com\/color-lyrics\/v2\/track\/</span> <span class="string">script-path=[https://raw.githubusercontent.com/fqw000/tools/main/s](https://raw.githubusercontent.com/fqw000/tools/main/rule/liby.list)cript/spotifylyric.js,</span> <span class="string">requires-body=true,</span> <span class="string">binary-body-mode=true,</span> <span class="string">timeout=10,</span> <span class="string">tag=Spotify歌词翻译,</span> <span class="string">argument=appid=xx&amp;securityKey=xxx</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>开启 mitm 和脚本即可正常使用</strong></p><p>#脚本来源 app2smile</p><h2 id="插件版："><a href="#插件版：" class="headerlink" title="插件版："></a>插件版：</h2><p>plugin:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!name= spotify 歌词</span></span><br><span class="line"><span class="comment">#!desc= 显示翻译按钮，手动翻译，不能随歌词滚动翻译。换行翻译。</span></span><br><span class="line">[Mitm]</span><br><span class="line">hostname =spclient.wg.spotify.com</span><br><span class="line"></span><br><span class="line">[Script]</span><br><span class="line">http-response ^https:\/\/spclient\.wg\.spotify\.com\/color-lyrics\/v2\/track\/ script-path=[https://raw.githubusercontent.com/fqw000/tools/main/s](https://raw.githubusercontent.com/fqw000/tools/main/rule/liby.list)cript/spotifylyric.js, requires-body=<span class="literal">true</span>, binary-body-mode=<span class="literal">true</span>, <span class="built_in">timeout</span>=10, tag=Spotify歌词翻译, argument=appid=xx&amp;securityKey=xxx</span><br></pre></td></tr></table></figure><p>sgmodule:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!name= spotify 歌词</span></span><br><span class="line"><span class="meta">#!desc= 显示翻译按钮，手动翻译，不能随歌词滚动翻译。换行翻译。</span></span><br><span class="line">[MITM]</span><br><span class="line">hostname = %APPEND% spclient.wg.spotify.com</span><br><span class="line">[Script]</span><br><span class="line"># 可调整为本地插件，修改下方argument中的appid和securityKey,填入自己的appid和密钥</span><br><span class="line"># 旧版自动随歌词滚动显示，原歌词同行显示，使用这个脚本： https:<span class="comment">//raw.githubusercontent.com/fqw000/tools/main/script/spotifyLyricBak.js</span></span><br><span class="line">spotify歌词翻译 = type=http-response,pattern=^https:\/\/spclient\.wg\.spotify\.com\/color-lyrics\/v2\/track\/,requires-<span class="keyword">body</span>=<span class="number">1</span>,binary-<span class="keyword">body</span>-mode=<span class="number">1</span>,max-size=<span class="number">0</span>,script-path=https:<span class="comment">//raw.githubusercontent.com/app2smile/rules/master/js/spotify-lyric.js,argument=appid=XXX&amp;securityKey=XXX</span></span><br></pre></td></tr></table></figure><h2 id="Spotify-歌词翻译使用百度翻译-api-的几点注意事项"><a href="#Spotify-歌词翻译使用百度翻译-api-的几点注意事项" class="headerlink" title="Spotify 歌词翻译使用百度翻译 api 的几点注意事项"></a>Spotify 歌词翻译使用百度翻译 api 的几点注意事项</h2><p>这两天发了 spotify 歌词翻译以后，部分网友私信协助其进行了配置，因为私信较多，可能在私信的过程中部分网友收到的代码里包含了我的百度翻译 api。今天发现欠费了……所以想给大家一些提示：</p><ul><li>流量<blockquote><p>通用翻译 API 标准版免费调用量调整为 5 万字符&#x2F;月，高级版免费调用量调整为 100 万字符&#x2F;月。<br>请选择 高级版，标准版可能不够用。<br>高级版比标准版相比要求多个了个人认证，需要身份证和手机号。</p></blockquote></li><li>费用<br>百度翻译是可以欠费的！采用的是次日结算的方式，欠费以后服务就被停用了，脚本无法使用翻译功能会提醒你检查 api 和 key 的配置。</li><li>必要设置<br>可以开通流量提醒、费用提醒。支持设置手机号和邮箱。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spotify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git安装后右键没有git bash的解决方案</title>
      <link href="/2023/06/06/Git%E5%AE%89%E8%A3%85%E5%90%8E%E5%8F%B3%E9%94%AE%E6%B2%A1%E6%9C%89git-bash%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/06/06/Git%E5%AE%89%E8%A3%85%E5%90%8E%E5%8F%B3%E9%94%AE%E6%B2%A1%E6%9C%89git-bash%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote><p>实现原理是使用注册表将 git bash 写入右键 1.将以下内容写入新建的.txt 文件。 2.修改.txt 为.reg。 3.双击点击运行。</p></blockquote><ul><li>文件内容：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Windows</span> <span class="type">Registry</span> <span class="type">Editor</span> <span class="type">Version</span> <span class="number">5.00</span></span><br><span class="line">; <span class="type">Open</span> files</span><br><span class="line">; <span class="type">Default</span> <span class="type">Git</span><span class="operator">-</span><span class="type">Bash</span> <span class="type">Location</span> <span class="type">C</span>:\<span class="type">Program</span> <span class="type">Files</span>\<span class="type">Git</span>\git<span class="operator">-</span>bash.exe</span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="operator">*</span>\shell\<span class="type">Open</span> <span class="type">Git</span> <span class="type">Bash</span>]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;Open Git Bash&quot;</span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span><span class="operator">=</span><span class="string">&quot;C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="operator">*</span>\shell\<span class="type">Open</span> <span class="type">Git</span> <span class="type">Bash</span>\command]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;<span class="subst">\&quot;</span>C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe<span class="subst">\&quot;</span> <span class="subst">\&quot;</span>--cd=%1<span class="subst">\&quot;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">; <span class="type">This</span> will make it appear when you right click <span class="type">ON</span> a folder</span><br><span class="line">; <span class="type">The</span> <span class="string">&quot;Icon&quot;</span> line can be removed <span class="keyword">if</span> you don&#x27;t want the icon to appear</span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\shell\bash]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;Open Git Bash&quot;</span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span><span class="operator">=</span><span class="string">&quot;C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\shell\bash\command]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;<span class="subst">\&quot;</span>C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe<span class="subst">\&quot;</span> <span class="subst">\&quot;</span>--cd=%1<span class="subst">\&quot;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">; <span class="type">This</span> will make it appear when you right click <span class="type">INSIDE</span> a folder</span><br><span class="line">; <span class="type">The</span> <span class="string">&quot;Icon&quot;</span> line can be removed <span class="keyword">if</span> you don&#x27;t want the icon to appear</span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\<span class="type">Background</span>\shell\bash]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;Open Git Bash&quot;</span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span><span class="operator">=</span><span class="string">&quot;C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\<span class="type">Background</span>\shell\bash\command]</span><br><span class="line">@<span class="operator">=</span><span class="string">&quot;<span class="subst">\&quot;</span>C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Git<span class="subst">\\</span>git-bash.exe<span class="subst">\&quot;</span> <span class="subst">\&quot;</span>--cd=%v.<span class="subst">\&quot;</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DEV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB</title>
      <link href="/2023/06/06/ADB/"/>
      <url>/2023/06/06/ADB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903645289398280#heading-15">ADB 操作命令详解及用法大全</a></p><p>下载解压 adb android-platform-tools</p><h2 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h2><table><thead><tr><th>zsh</th><th>.zshrc</th><th>home path</th></tr></thead></table><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>cmd</th><th>usage</th><th>cmd</th><th>usage</th><th>cmd</th><th>usage</th></tr></thead><tbody><tr><td>adb version</td><td>查看版本号</td><td>adb start-server</td><td>启动 adb 服务</td><td>adb kill-server</td><td>终止 adb 服务</td></tr><tr><td>adb devices</td><td>连接的设备</td><td>adb root</td><td>以 root 身份使用 adb</td><td>adb -p <port> start-server</td><td>指定 adb 端口，默认 5037</td></tr><tr><td>adb connect:port</td><td>通过制定端口连接制定 ip 的机器</td><td>adb disconnect</td><td>断开链接</td><td>adb usb</td><td>以 usb 模式重新启动 adb</td></tr></tbody></table><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>adb 默认的端口号为 5555 ，连接设备是可以使用<code>adb connect 目标IP</code> 等同于 <code>adb connect 目标IP:5555</code></p><p>修改端口可以使用 <code>adb tcpip 端口号</code> 实现，例如 <code>adb tcpip 8888</code></p><h2 id="进阶玩法："><a href="#进阶玩法：" class="headerlink" title="进阶玩法："></a>进阶玩法：</h2><p>重置 adb 网络监听端口的两种方法：</p><p>方法 1：通过 usb 线连接电脑跟安卓设备，输入 adb 命令：adb tcpip 5555 ；该条命令是设置网络 adb 监听的端口，5555 是默认，也可设置为其它的。(重启失效)</p><p>方法 2：使用文件管理器按照以下路径打开文件：&#x2F;system&#x2F;build.prop，在该文件的最后添加以下内容：service.adb.tcp.port&#x3D;5555 (重启依然有效，可以有线或无线操作)</p><p>注：方法 2 比较稳定，重启后端口号依然能保持，但是修改 build.prop 文件需要 root 权限。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>有时候 devices 后面出现 unauthorized 的解决方案：</li></ul><p>依次运行以下命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">TMPDIR</span>=/sdcard/.android/tmp</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">HOME</span>=/sdcard</span><br><span class="line">adb kill-server</span><br><span class="line">adb devices</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>failed to start daemon , can’t connect to daemon</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb nodaemon <span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>应用管理</p><h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><p>查看</p><p>adb shell pm list packages [options]</p><table><thead><tr><th>参数</th><th>显示</th></tr></thead><tbody><tr><td>-f</td><td>显示应用关联的 apk 文件</td></tr><tr><td>-d</td><td>显示 disable 的应用</td></tr><tr><td>-e</td><td>显示 enabled 的应用</td></tr><tr><td>-s</td><td>显示系统应用</td></tr><tr><td>-3</td><td>显示第三方应用</td></tr><tr><td>-i</td><td>显示应用的 installer</td></tr><tr><td>-u</td><td>包含已卸载应用</td></tr><tr><td><filter></td><td>包含制定字符的应用</td></tr><tr><td>无</td><td>所有应用</td></tr></tbody></table><p>安装</p><p>adb install <package-name></p><p>安装文件需要放置在当前目录下</p><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>-l</td><td>安装到保护目录&#x2F;mnt&#x2F;asec</td></tr><tr><td>-r</td><td>允许覆盖安装</td></tr><tr><td>-t</td><td>允许安装 androidManifest.xml 里的 application 指定 android：testOnly&#x3D;ture 的应用</td></tr><tr><td>-s</td><td>将应用安装到 sdcard</td></tr><tr><td>-d</td><td>允许降级覆盖安装</td></tr><tr><td>-g</td><td>授予运行时到权限</td></tr></tbody></table><p>卸载</p><p>adb uninstall [-k] [package-name]</p><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>-k</td><td>卸载时保留数据和缓存目录</td></tr></tbody></table><p>清除应用数据和缓存</p><p>adb shell pm clear <package-name></p><p>查看应用安装路径</p><p>adb shell pm path <package-name></p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;查看前台 activity</p><p>adb shell dumpsys activity activities | grep moucusedActivity</p><p>查看正在运行的 services</p><p>adb shell dumpsys activity services <package-name></p><p>adb shell dumpsys activity services</p><p>查看应用详细信息</p><p>adb shell dumpsys package <package-name></p><p>启动应用</p><p>adb shell am start <package-name></p><p>adb shell am start <package-name>&#x2F;.Activity(需要启动的 activity)</p><p>交互</p><p>强制停止应用</p><p>adb shell am force-stop <package-name></p><p>收紧内存</p><p>adb shell am send-trim-memory <pid> <level></p><p>pid:进程 id</p><p>level：HIDDEN RUNNING_MODERATE BACKGROUND RUNING_LOW MODERATE RUNNING_CRITICAL COMPLETE</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>从设备下载文件到本地</p><p>adb pull <remote> [local]</p><p>remote：模拟器&#x2F;设备的文件路径</p><p>local：本地路径，留空默认即当前目录</p><p>将本地文件推送到设备</p><p>adb push <local> [remote]</p><p>列出制定目录的内容</p><p>adb shell ls [option] <directory></p><p>directory:制定目录，省略即当前</p><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>无</td><td>所有文件和目录</td></tr><tr><td>-a</td><td>所有文件包括隐藏</td></tr><tr><td>-i</td><td>所有文件和索引编号</td></tr><tr><td>-s</td><td>所有文件和文件大小</td></tr><tr><td>-n</td><td>所有文件和 uid gid</td></tr><tr><td>-R</td><td>所有子目录的文件</td></tr></tbody></table><p>切换到目录</p><p>adb shell cd <directory></p><p>删除</p><p>adb shell rm [iptions] &lt;file&#x2F;directory&gt;</p><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>无</td><td>删除文件</td></tr><tr><td>-f</td><td>强制删除，不提示</td></tr><tr><td>-r</td><td>强制删除制定目录下的所有内容</td></tr><tr><td>-d</td><td>删除指定目录，等同于 rmdir</td></tr><tr><td>-i</td><td>交互删除，删除前提示</td></tr></tbody></table><p>创建目录</p><p>adb shell mkdir [options] <directory-name></p><p>同样类型的 adb shel 命令有</p><p>pwd</p><p>cp</p><p>mv</p><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>网络信息查看</p><p>adb shell netstat</p><p>将网络信息输出到制定文件</p><p>adb shell netstat&gt;<file-path></p><p>ping</p><p>adb shell ping destination</p><p>查看 ip</p><p>adb shell ifconfig | grep Mask</p><p>如果不行，使用一下命令：</p><p>adb shell netcfg</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><p>菜单</p><p>adb shell input keyevent 82</p><p>home 键</p><p>adb shell input keyevent 3</p><p>返回键</p><p>adb shell input keyevent 4</p><p>静音</p><p>adb shell input keyevent 164</p><p>亮屏</p><p>adb shell input keyevent 224</p><p>关屏</p><p>adb shell input keyevent 223</p><p>滑动解锁</p><p>adb shell input swipe 300 1000 300 500</p><p>300 1000 300 500 代表起点 x 坐标 起点 y 坐标 结束 x 坐标 结束 y 坐标</p><p>焦点处于文本框时输入文本</p><p>adb shell input text &lt;输入内容&gt;</p><p>（英文输入法下可输入英文，中文异常）</p><h2 id="日志及其他"><a href="#日志及其他" class="headerlink" title="日志及其他"></a>日志及其他</h2><p>清空日志</p><p>adb logcat -c</p><p>显示日志在控制台</p><p>adb logcat -d</p><p>查看电池状况</p><p>adb shell dumpsys battery</p><p>查看分辨率</p><p>adb shell wm size</p><p>查看屏幕密度</p><p>adb shell wm density</p><p>查看屏幕参数</p><p>adb shell dumpsys window displays</p><p>查看设备 android id</p><p>adb shell settings get secure android_id</p><p>查看 android 系统版本</p><p>adb shell getprop ro.build.version.release</p><p>查看 mac 地址</p><p>adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wan0&#x2F;address</p><p>截图</p><p>adb exec-out screencap -p &gt; sc.png</p><p>重启</p><p>adb reboot</p><p>查看当前 activity</p><p>adb shell dumpsys activity activities | grep mResumedActivity</p><p>》〉》〉华为后台调用 activity</p><p>om.huawei.android.launcher&#x2F;.quickstep.RecentsActivit</p><p>adb 调起多任务管理</p><p>adb shell am start -n com.huawei.android.launcher&#x2F;.quickstep.RecentsActivity</p>]]></content>
      
      
      
        <tags>
            
            <tag> DEV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regex 正则表达式</title>
      <link href="/2023/06/06/Regex-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/06/06/Regex-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="RegularExpression"><a href="#RegularExpression" class="headerlink" title="RegularExpression"></a>RegularExpression</h2><p>Regux &#x2F; Reguxp</p><h2 id="语法构成"><a href="#语法构成" class="headerlink" title="语法构成"></a>语法构成</h2><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>涵盖：大小写字母、数字、标点、特殊符号</p><table><thead><tr><th>打印字符</th><th>描述</th></tr></thead><tbody><tr><td>abc</td><td>匹配所有字符中的 abc。注意与[abc]的区别</td></tr><tr><td>[abc]</td><td>字符簇。匹配所有字符中单个的 a、b 或 c。[a | b | c]</td></tr><tr><td>[a-z]</td><td>字符簇。匹配所有字符中的任一小写字母。</td></tr><tr><td>[A-Z]</td><td>字符簇。 匹配所有字符中的任一大写字母。</td></tr><tr><td>[0-9]</td><td>字符簇。 匹配所有字符中的任一数字。</td></tr><tr><td>[^abc]</td><td>字符簇。匹配所有字符中非的 a、b 或 c。</td></tr><tr><td>.</td><td>匹配除换行(\n、\r)之外的任一字符。[^\n\r]</td></tr><tr><td>[\s]</td><td>匹配所有的空白字符包括换行符、空格、制表符、换页符等。</td></tr><tr><td>[\S]</td><td>匹配所有的非空白字符不包括换行符、制表符、换页符。[^\f\n\r\t\v]</td></tr><tr><td>[\w]</td><td>匹配任一数字、字母、下划线 。[0-9a-zA-Z_]</td></tr><tr><td>[\W]</td><td>匹配任一非单词字符。[^0-9a-zA-Z_]</td></tr><tr><td>[\d]</td><td>匹配任一数字字符。[0-9]</td></tr><tr><td>[\D]</td><td>匹配任一非数字字符，包括字母、空格、下划线。[^0-9]</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table><thead><tr><th>非打印字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>匹配为 x 字母的控制字符。x 可以是任一字母。</td></tr><tr><td>\f</td><td>匹配一个换页符。\x0c 、\cL</td></tr><tr><td>\n</td><td>匹配一个换行符。</td></tr><tr><td>\r</td><td>匹配一个回车符。</td></tr><tr><td>\t</td><td>匹配一个制表符。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。</td></tr><tr><td>\num</td><td>匹配正整数 num，对所获取的匹配的引用。</td></tr></tbody></table><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配整个字符串的开始位置。</td></tr><tr><td>$</td><td>匹配整个字符串的结束位置。</td></tr><tr><td>*</td><td>匹配前一个子表达式零次及以上。{0,}</td></tr><tr><td>+</td><td>匹配前一个子表达式一次及以上。{1,}</td></tr><tr><td>?</td><td>匹配前一个子表达式零次到一次。{0,1}</td></tr><tr><td>.</td><td>匹配除换行符之外的任一字符。</td></tr><tr><td>\</td><td>转义字符。将下一个字符标记为特殊字符、原意字符或向后引用，或八进制转义字符。</td></tr><tr><td>()</td><td>标记一个组（子表达式）。定义操作符的范围和有限级。选择项必须要放置在()中。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。</td></tr><tr><td>]</td><td>标记一个中括号表达式的结束。</td></tr><tr><td>{</td><td>标记限定符表达式开始。</td></tr><tr><td>}</td><td>标记限定符表达式结束。</td></tr><tr><td>|</td><td>或。匹配前后两项中的任一个。优先级最低。</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>表述指定的<code>正则组件</code>必须出现的次数才符合匹配</p><table><thead><tr><th>限定符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个子表达式零次及以上。{0,}</td></tr><tr><td>+</td><td>匹配前一个子表达式一次及以上。{1,}</td></tr><tr><td>？</td><td>匹配前一个子表达式零次到一次。{0,1}。跟在任一其他限定符后面时，表示匹配模式是非贪婪的，即尽可能少的匹配描述的字符串。</td></tr><tr><td>{n}</td><td>匹配前一个子表达式 n 次。</td></tr><tr><td>{n,}</td><td>匹配前一个子表达式 n 次及以上。</td></tr><tr><td>{n,m}</td><td>匹配前一个子表达式 n 次到 m 次。</td></tr></tbody></table><h3 id="定位符-锚点"><a href="#定位符-锚点" class="headerlink" title="定位符(锚点)"></a>定位符(锚点)</h3><table><thead><tr><th>定位符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串的开始位置。</td></tr><tr><td>$</td><td>匹配字符串的结束位置。</td></tr><tr><td>\b</td><td>匹配一个单词的边界(wordboundary，A word boundary is a zero-width test between two characters)。匹配字符与空格之间的位置。即匹配前一个子表达式且在单词的收尾或开头(取决于\b 放置的位置)</td></tr><tr><td>\B</td><td>匹配非单词的边界。匹配单词间字符与字符之间的边界。即匹配前一个子表达式且前一个表达式不能在字符串的收尾或开头(取决于\B 放置的位置)</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="组与引用"><a href="#组与引用" class="headerlink" title="组与引用"></a>组与引用</h3><p>（）表示捕获分组</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>()</td><td>捕获分组，把每个分组里匹配的值保存起来，多个可通过用 n 表示组的序号来查看</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><table><thead><tr><th>非捕获元</th><th>描述</th></tr></thead><tbody><tr><td>(?:pattern)</td><td>非捕获组，创建无法引用的分组。</td></tr><tr><td>(?&#x3D;pattern)</td><td>正向预查，在任何开始匹配圆括号内表达式的位置查询。匹配的元素后方紧跟着需要有能匹配括号内表达式匹配到的元素。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查。在任何不匹配该表达式的位置查询。匹配到的元素后方紧跟着的不能含有括号内表达式匹配的元素。</td></tr><tr><td>(?&lt;&#x3D;pattern)</td><td>反向肯定预查。匹配元素的前一个元素是括号表达式陪陪的元素。</td></tr><tr><td>(?&lt;!&#x3D;pattern)</td><td>反向否定预查。匹配元素的前一个元素不能是括号表达式陪陪的元素。</td></tr></tbody></table><table><thead><tr><th>示例</th><th>描述</th></tr></thead><tbody><tr><td>r(?&#x3D;e)</td><td>匹配单词中后面有 e 的 r</td></tr><tr><td>r(?!e)</td><td>匹配单词中后面没有 e 的 r</td></tr><tr><td>(?&lt;&#x3D;e)r</td><td>匹配前面有 e 的 r</td></tr><tr><td>(?&lt;!&#x3D;e)r</td><td>匹配前面没有 e 的 r</td></tr></tbody></table><h3 id="flags-标志"><a href="#flags-标志" class="headerlink" title="flags 标志"></a>flags 标志</h3><p>flags 放置在 pattern 的后面，可以是多个 flags 同时使用。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写。</td></tr><tr><td>g</td><td>全局查找，确保表达式不会在第一个匹配项时停止。</td></tr><tr><td>m</td><td>多行查找，不启用^和$只匹配整个字符串的开始和结束，而不会单独匹配每一行。</td></tr><tr><td>s</td><td>默认.匹配的是除换行\n 以外的任一字符，加上 s 后.可以匹配包括换行在內的任一字符。</td></tr></tbody></table><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><table><thead><tr><th>优先级</th><th>符号</th></tr></thead><tbody><tr><td>最高</td><td>\</td></tr><tr><td>高</td><td>()、(?:)、(?&#x3D;)、[]</td></tr><tr><td>中</td><td>*、+、?、{n}、{n,}、{n,m}</td></tr><tr><td>低</td><td>^、$、中介字符</td></tr><tr><td>次低</td><td>串联。相邻的字符连接在一起</td></tr><tr><td>最低</td><td>｜</td></tr></tbody></table><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e06eed0-cf1c-44e7-a0bc-aee4e33945f9/Untitled.png" alt="正则表达的解析"></p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>shell 的 sed 不支持、\d、\D、零宽断言，且 sed 下的正则表达没有懒惰模式，都是贪婪模式。</p><h2 id="Per"><a href="#Per" class="headerlink" title="Per"></a>Per</h2><p>可更好的替代 sed 使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DEV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
